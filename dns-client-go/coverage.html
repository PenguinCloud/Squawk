
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>squawk-dns-client: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/penguincloud/squawk/dns-client-go/cmd/squawk-dns-client/main.go (0.0%)</option>
				
				<option value="file1">github.com/penguincloud/squawk/dns-client-go/pkg/client/doh_client.go (0.0%)</option>
				
				<option value="file2">github.com/penguincloud/squawk/dns-client-go/pkg/config/config.go (0.0%)</option>
				
				<option value="file3">github.com/penguincloud/squawk/dns-client-go/pkg/forwarder/forwarder.go (0.0%)</option>
				
				<option value="file4">github.com/penguincloud/squawk/dns-client-go/pkg/license/validator.go (0.0%)</option>
				
				<option value="file5">github.com/penguincloud/squawk/dns-client-go/pkg/logger/logger.go (0.0%)</option>
				
				<option value="file6">github.com/penguincloud/squawk/dns-client-go/pkg/performance/dns_performance.go (0.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">no coverage</span>
				<span class="cov1">low coverage</span>
				<span class="cov2">*</span>
				<span class="cov3">*</span>
				<span class="cov4">*</span>
				<span class="cov5">*</span>
				<span class="cov6">*</span>
				<span class="cov7">*</span>
				<span class="cov8">*</span>
				<span class="cov9">*</span>
				<span class="cov10">high coverage</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package main

import (
        "context"
        "encoding/json"
        "fmt"
        "log"
        "os"
        "os/signal"
        "strings"
        "syscall"
        "time"

        "github.com/penguincloud/squawk/dns-client-go/pkg/client"
        "github.com/penguincloud/squawk/dns-client-go/pkg/config"
        "github.com/penguincloud/squawk/dns-client-go/pkg/forwarder"
        "github.com/penguincloud/squawk/dns-client-go/pkg/license"
        "github.com/penguincloud/squawk/dns-client-go/pkg/logger"
        "github.com/penguincloud/squawk/dns-client-go/pkg/performance"
        "github.com/spf13/cobra"
)

var (
        // Global flags
        configFile  string
        domain      string
        recordType  string
        serverURL   string
        authToken   string
        clientCert  string
        clientKey   string
        caCert      string
        verifySSL   bool
        udpForward  bool
        tcpForward  bool
        verbose     bool
        jsonOutput  bool
        enablePerformanceMonitoring bool

        // Version information
        version   = "1.0.0"
        buildTime = "unknown"
        gitCommit = "unknown"
)

func main() <span class="cov0" title="0">{
        if err := rootCmd.Execute(); err != nil </span><span class="cov0" title="0">{
                fmt.Fprintf(os.Stderr, "Error: %v\n", err)
                os.Exit(1)
        }</span>
}

var rootCmd = &amp;cobra.Command{
        Use:   "squawk-dns-client",
        Short: "Squawk DNS-over-HTTPS Client",
        Long: `A DNS-over-HTTPS client with mTLS support and local DNS forwarding capabilities.
Compatible with the Squawk DNS server and supports bearer token authentication.`,
        Version: fmt.Sprintf("%s (built %s, commit %s)", version, buildTime, gitCommit),
        Run:     runClient,
}

func init() <span class="cov0" title="0">{
        // Global flags
        rootCmd.PersistentFlags().StringVarP(&amp;configFile, "config", "c", "", "Configuration file path")
        rootCmd.PersistentFlags().BoolVarP(&amp;verbose, "verbose", "v", false, "Enable verbose output")
        
        // DNS query flags
        rootCmd.Flags().StringVarP(&amp;domain, "domain", "d", "", "Domain to query (required)")
        rootCmd.Flags().StringVarP(&amp;recordType, "type", "t", "A", "DNS record type")
        rootCmd.Flags().BoolVarP(&amp;jsonOutput, "json", "j", false, "Output in JSON format")
        
        // Server connection flags
        rootCmd.Flags().StringVarP(&amp;serverURL, "server", "s", "", "DNS server URL")
        rootCmd.Flags().StringVarP(&amp;authToken, "auth", "a", "", "Authentication token")
        
        // mTLS flags
        rootCmd.Flags().StringVar(&amp;clientCert, "client-cert", "", "Client certificate file for mTLS")
        rootCmd.Flags().StringVar(&amp;clientKey, "client-key", "", "Client private key file for mTLS")
        rootCmd.Flags().StringVar(&amp;caCert, "ca-cert", "", "CA certificate file for server verification")
        rootCmd.Flags().BoolVar(&amp;verifySSL, "verify-ssl", true, "Verify SSL/TLS certificates")
        
        // DNS forwarding flags
        rootCmd.Flags().BoolVarP(&amp;udpForward, "udp", "u", false, "Enable UDP DNS forwarding on port 53")
        rootCmd.Flags().BoolVarP(&amp;tcpForward, "tcp", "T", false, "Enable TCP DNS forwarding on port 53")
        
        // Performance monitoring flags
        rootCmd.Flags().BoolVar(&amp;enablePerformanceMonitoring, "performance", false, "Enable DNS performance monitoring (Enterprise feature)")

        // Add subcommands
        rootCmd.AddCommand(forwardCmd)
        rootCmd.AddCommand(configCmd)
        rootCmd.AddCommand(versionCmd)
        rootCmd.AddCommand(licenseCmd)
}</span>

// runClient is the main client function
func runClient(cmd *cobra.Command, args []string) <span class="cov0" title="0">{
        // Load configuration
        cfg, err := loadConfiguration()
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Configuration error: %v", err)
        }</span>

        // Override config with command line flags
        <span class="cov0" title="0">overrideConfigWithFlags(cmd, cfg)

        if verbose </span><span class="cov0" title="0">{
                fmt.Println(cfg.String())
        }</span>

        // Check if license is configured - skip validation if not (backward compatibility)
        <span class="cov0" title="0">if cfg.License.LicenseKey != "" || cfg.License.UserToken != "" </span><span class="cov0" title="0">{
                // Validate license before proceeding
                validator := license.NewValidator(cfg.License)
                ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)
                defer cancel()

                isValid, err := validator.IsValid(ctx)
                if err != nil </span><span class="cov0" title="0">{
                        if verbose </span><span class="cov0" title="0">{
                                fmt.Printf("License validation warning: %v\n", err)
                        }</span>
                        // Allow offline operation for now, but warn user
                        <span class="cov0" title="0">fmt.Println("Warning: Could not validate license. Some features may be restricted.")</span>
                } else<span class="cov0" title="0"> if !isValid </span><span class="cov0" title="0">{
                        fmt.Println("ERROR: Invalid or expired license. Please check your license key or user token.")
                        fmt.Println("Contact your administrator for license assistance.")
                        os.Exit(1)
                }</span> else<span class="cov0" title="0"> if verbose </span><span class="cov0" title="0">{
                        fmt.Println("âœ“ License validated successfully")
                        if info, err := validator.GetLicenseInfo(ctx); err == nil </span><span class="cov0" title="0">{
                                fmt.Println(info)
                        }</span>
                }
        } else<span class="cov0" title="0"> if verbose </span><span class="cov0" title="0">{
                fmt.Println("Note: No license configured. Running in compatibility mode.")
                fmt.Println("For premium features, configure SQUAWK_LICENSE_KEY or SQUAWK_USER_TOKEN.")
        }</span>

        // Use license user token for DNS requests if available and no explicit auth token set
        <span class="cov0" title="0">if cfg.License.UserToken != "" &amp;&amp; cfg.Client.AuthToken == "" </span><span class="cov0" title="0">{
                cfg.Client.AuthToken = cfg.License.UserToken
                if verbose </span><span class="cov0" title="0">{
                        fmt.Println("Using license user token for DNS authentication")
                }</span>
        }

        // Validate domain is provided
        <span class="cov0" title="0">if cfg.Domain == "" </span><span class="cov0" title="0">{
                fmt.Fprintf(os.Stderr, "Error: domain is required. Use -d &lt;domain&gt; or set SQUAWK_DOMAIN environment variable.\n")
                os.Exit(1)
        }</span>

        // Create DoH client
        <span class="cov0" title="0">dohClient, err := client.NewDoHClient(cfg.Client)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Failed to create DoH client: %v", err)
        }</span>
        <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{
                if err := dohClient.Close(); err != nil </span><span class="cov0" title="0">{
                        log.Printf("Warning: failed to close DoH client: %v", err)
                }</span>
        }()

        // If forwarding is enabled, start forwarder and wait
        <span class="cov0" title="0">if cfg.Forwarder.ListenUDP || cfg.Forwarder.ListenTCP </span><span class="cov0" title="0">{
                runForwarder(dohClient, cfg)
                return
        }</span>

        // Perform single DNS query
        <span class="cov0" title="0">ctx, cancel := context.WithTimeout(context.Background(), 30*time.Second)
        defer cancel()

        response, err := dohClient.Query(ctx, cfg.Domain, cfg.RecordType)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("DNS query failed: %v", err)
        }</span>

        // Output results
        <span class="cov0" title="0">if jsonOutput </span><span class="cov0" title="0">{
                jsonData, _ := json.MarshalIndent(response, "", "  ")
                fmt.Println(string(jsonData))
        }</span> else<span class="cov0" title="0"> {
                printDNSResponse(response)
        }</span>
}

// loadConfiguration loads the configuration from file and environment
func loadConfiguration() (*config.AppConfig, error) <span class="cov0" title="0">{
        return config.LoadConfig(configFile)
}</span>

// overrideConfigWithFlags overrides configuration with command line flags
func overrideConfigWithFlags(cmd *cobra.Command, cfg *config.AppConfig) <span class="cov0" title="0">{
        if domain != "" </span><span class="cov0" title="0">{
                cfg.Domain = domain
        }</span>
        <span class="cov0" title="0">if recordType != "" </span><span class="cov0" title="0">{
                cfg.RecordType = recordType
        }</span>
        <span class="cov0" title="0">if serverURL != "" </span><span class="cov0" title="0">{
                cfg.Client.ServerURL = serverURL
        }</span>
        <span class="cov0" title="0">if authToken != "" </span><span class="cov0" title="0">{
                cfg.Client.AuthToken = authToken
        }</span>
        <span class="cov0" title="0">if clientCert != "" </span><span class="cov0" title="0">{
                cfg.Client.ClientCert = clientCert
        }</span>
        <span class="cov0" title="0">if clientKey != "" </span><span class="cov0" title="0">{
                cfg.Client.ClientKey = clientKey
        }</span>
        <span class="cov0" title="0">if caCert != "" </span><span class="cov0" title="0">{
                cfg.Client.CaCert = caCert
        }</span>
        <span class="cov0" title="0">if cmd.Flags().Changed("verify-ssl") </span><span class="cov0" title="0">{
                cfg.Client.VerifySSL = verifySSL
        }</span>
        <span class="cov0" title="0">if udpForward </span><span class="cov0" title="0">{
                cfg.Forwarder.ListenUDP = true
        }</span>
        <span class="cov0" title="0">if tcpForward </span><span class="cov0" title="0">{
                cfg.Forwarder.ListenTCP = true
        }</span>
}

// runForwarder starts the DNS forwarder service
func runForwarder(dohClient *client.DoHClient, cfg *config.AppConfig) <span class="cov0" title="0">{
        fwd := forwarder.NewForwarder(dohClient, cfg.Forwarder)

        // Handle graceful shutdown
        ctx, cancel := context.WithCancel(context.Background())
        defer cancel()

        // Setup signal handling
        sigChan := make(chan os.Signal, 1)
        signal.Notify(sigChan, syscall.SIGINT, syscall.SIGTERM)

        // Setup performance monitoring if enabled
        var perfMonitor *performance.DNSPerformanceMonitor
        if enablePerformanceMonitoring </span><span class="cov0" title="0">{
                // Create simple logger
                log := logger.NewSimpleLogger(verbose)
                
                // Initialize performance monitor
                perfMonitor = performance.NewDNSPerformanceMonitor(cfg.Client, log)
                
                if err := perfMonitor.Start(); err != nil </span><span class="cov0" title="0">{
                        log.Printf("Failed to start performance monitoring: %v", err)
                }</span> else<span class="cov0" title="0"> if verbose </span><span class="cov0" title="0">{
                        fmt.Println("âœ“ DNS performance monitoring enabled")
                }</span>
        }

        // Start forwarder in goroutine
        <span class="cov0" title="0">go func() </span><span class="cov0" title="0">{
                if err := fwd.Start(ctx); err != nil </span><span class="cov0" title="0">{
                        log.Printf("Forwarder error: %v", err)
                }</span>
        }()

        // Wait for shutdown signal
        <span class="cov0" title="0">&lt;-sigChan
        log.Println("Received shutdown signal, stopping services...")
        
        // Stop performance monitoring first
        if perfMonitor != nil </span><span class="cov0" title="0">{
                if err := perfMonitor.Stop(); err != nil </span><span class="cov0" title="0">{
                        log.Printf("Error stopping performance monitor: %v", err)
                }</span>
        }
        
        <span class="cov0" title="0">cancel()

        // Give some time for graceful shutdown
        time.Sleep(1 * time.Second)</span>
}

// printDNSResponse prints the DNS response in a human-readable format
func printDNSResponse(response *client.DNSResponse) <span class="cov0" title="0">{
        fmt.Printf("DNS Response Status: %d\n", response.Status)
        
        if response.Comment != "" </span><span class="cov0" title="0">{
                fmt.Printf("Comment: %s\n", response.Comment)
        }</span>

        <span class="cov0" title="0">if len(response.Answer) &gt; 0 </span><span class="cov0" title="0">{
                fmt.Println("Answers:")
                for _, answer := range response.Answer </span><span class="cov0" title="0">{
                        fmt.Printf("  %s -&gt; %s (TTL: %d)\n", answer.Name, answer.Data, answer.TTL)
                }</span>
        } else<span class="cov0" title="0"> {
                fmt.Println("No answers found")
        }</span>
}

// Forward command
var forwardCmd = &amp;cobra.Command{
        Use:   "forward",
        Short: "Start DNS forwarding service",
        Long: `Start the DNS forwarding service to forward traditional DNS queries to DNS-over-HTTPS.
This will listen on the configured UDP and/or TCP addresses and forward all DNS queries
to the configured DoH server.`,
        Run: func(cmd *cobra.Command, args []string) <span class="cov0" title="0">{
                // Load configuration
                cfg, err := loadConfiguration()
                if err != nil </span><span class="cov0" title="0">{
                        log.Fatalf("Configuration error: %v", err)
                }</span>

                // Override with flags
                <span class="cov0" title="0">overrideConfigWithFlags(cmd, cfg)

                // Force forwarding to be enabled
                if !udpForward &amp;&amp; !tcpForward </span><span class="cov0" title="0">{
                        cfg.Forwarder.ListenUDP = true
                        cfg.Forwarder.ListenTCP = true
                }</span>

                <span class="cov0" title="0">if verbose </span><span class="cov0" title="0">{
                        fmt.Println(cfg.String())
                }</span>

                // Check if license is configured for forwarder
                <span class="cov0" title="0">if cfg.License.LicenseKey != "" || cfg.License.UserToken != "" </span><span class="cov0" title="0">{
                        // Validate license before starting forwarder
                        validator := license.NewValidator(cfg.License)
                        ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)
                        defer cancel()

                        isValid, err := validator.IsValid(ctx)
                        if err != nil </span><span class="cov0" title="0">{
                                fmt.Printf("Warning: Could not validate license: %v\n", err)
                                fmt.Println("DNS forwarding will continue, but some features may be restricted.")
                        }</span> else<span class="cov0" title="0"> if !isValid </span><span class="cov0" title="0">{
                                fmt.Println("ERROR: Invalid or expired license required for DNS forwarding service.")
                                fmt.Println("Contact your administrator for license assistance.")
                                os.Exit(1)
                        }</span> else<span class="cov0" title="0"> if verbose </span><span class="cov0" title="0">{
                                fmt.Println("âœ“ License validated successfully")
                        }</span>
                } else<span class="cov0" title="0"> if verbose </span><span class="cov0" title="0">{
                        fmt.Println("Note: No license configured. DNS forwarding running in compatibility mode.")
                        fmt.Println("For premium features, configure SQUAWK_LICENSE_KEY or SQUAWK_USER_TOKEN.")
                }</span>

                // Use license user token for DNS requests if available and no explicit auth token set
                <span class="cov0" title="0">if cfg.License.UserToken != "" &amp;&amp; cfg.Client.AuthToken == "" </span><span class="cov0" title="0">{
                        cfg.Client.AuthToken = cfg.License.UserToken
                        if verbose </span><span class="cov0" title="0">{
                                fmt.Println("Using license user token for DNS authentication")
                        }</span>
                }

                // Create DoH client
                <span class="cov0" title="0">dohClient, err := client.NewDoHClient(cfg.Client)
                if err != nil </span><span class="cov0" title="0">{
                        log.Fatalf("Failed to create DoH client: %v", err)
                }</span>
                <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{
                if err := dohClient.Close(); err != nil </span><span class="cov0" title="0">{
                        log.Printf("Warning: failed to close DoH client: %v", err)
                }</span>
        }()

                // Run forwarder
                <span class="cov0" title="0">runForwarder(dohClient, cfg)</span>
        },
}

// Config command
var configCmd = &amp;cobra.Command{
        Use:   "config",
        Short: "Configuration management commands",
        Long:  "Commands for managing configuration files and displaying current settings",
}

var configShowCmd = &amp;cobra.Command{
        Use:   "show",
        Short: "Show current configuration",
        Run: func(cmd *cobra.Command, args []string) <span class="cov0" title="0">{
                cfg, err := loadConfiguration()
                if err != nil </span><span class="cov0" title="0">{
                        log.Fatalf("Configuration error: %v", err)
                }</span>
                <span class="cov0" title="0">fmt.Println(cfg.String())</span>
        },
}

var configEnvCmd = &amp;cobra.Command{
        Use:   "env",
        Short: "Show supported environment variables",
        Run: func(cmd *cobra.Command, args []string) <span class="cov0" title="0">{
                fmt.Println("Supported Environment Variables:")
                fmt.Println("=================================")
                for _, env := range config.GetEnvVarList() </span><span class="cov0" title="0">{
                        value := os.Getenv(env)
                        if value != "" </span><span class="cov0" title="0">{
                                if strings.Contains(strings.ToLower(env), "token") </span><span class="cov0" title="0">{
                                        value = "***masked***"
                                }</span>
                                <span class="cov0" title="0">fmt.Printf("%-25s = %s\n", env, value)</span>
                        } else<span class="cov0" title="0"> {
                                fmt.Printf("%-25s = (not set)\n", env)
                        }</span>
                }
        },
}

var configGenerateCmd = &amp;cobra.Command{
        Use:   "generate [filename]",
        Short: "Generate example configuration file",
        Args:  cobra.MaximumNArgs(1),
        Run: func(cmd *cobra.Command, args []string) <span class="cov0" title="0">{
                filename := "squawk-client.yaml"
                if len(args) &gt; 0 </span><span class="cov0" title="0">{
                        filename = args[0]
                }</span>

                <span class="cov0" title="0">cfg := config.DefaultConfig()
                cfg.Domain = "example.com"
                cfg.Client.ServerURL = "https://dns.example.com:8443"
                cfg.Client.AuthToken = "your-token-here"

                if err := config.SaveConfig(cfg, filename); err != nil </span><span class="cov0" title="0">{
                        log.Fatalf("Failed to generate config: %v", err)
                }</span>

                <span class="cov0" title="0">fmt.Printf("Generated example configuration: %s\n", filename)</span>
        },
}

// Version command
var versionCmd = &amp;cobra.Command{
        Use:   "version",
        Short: "Show version information",
        Run: func(cmd *cobra.Command, args []string) <span class="cov0" title="0">{
                fmt.Printf("Squawk DNS Client (Go)\n")
                fmt.Printf("Version: %s\n", version)
                fmt.Printf("Build Time: %s\n", buildTime)
                fmt.Printf("Git Commit: %s\n", gitCommit)
        }</span>,
}

// License command
var licenseCmd = &amp;cobra.Command{
        Use:   "license",
        Short: "License management and validation",
        Long:  "Manage and validate your Squawk DNS license and user tokens",
}

// License status command
var licenseStatusCmd = &amp;cobra.Command{
        Use:   "status",
        Short: "Check license status",
        Long:  "Validate and display current license or user token status",
        Run: func(cmd *cobra.Command, args []string) <span class="cov0" title="0">{
                // Load configuration
                cfg, err := loadConfiguration()
                if err != nil </span><span class="cov0" title="0">{
                        log.Fatalf("Configuration error: %v", err)
                }</span>

                // Create validator
                <span class="cov0" title="0">validator := license.NewValidator(cfg.License)
                ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)
                defer cancel()

                // Check status
                status, err := validator.GetStatus(ctx)
                if err != nil </span><span class="cov0" title="0">{
                        fmt.Printf("Error validating license: %v\n", err)
                        os.Exit(1)
                }</span>

                // Display status
                <span class="cov0" title="0">if status.Valid </span><span class="cov0" title="0">{
                        fmt.Println("âœ“ License is valid")
                }</span> else<span class="cov0" title="0"> {
                        fmt.Println("âœ— License is invalid or expired")
                }</span>

                <span class="cov0" title="0">if status.Message != "" </span><span class="cov0" title="0">{
                        fmt.Printf("Message: %s\n", status.Message)
                }</span>

                <span class="cov0" title="0">if status.ExpiresAt != nil </span><span class="cov0" title="0">{
                        fmt.Printf("Expires: %s\n", *status.ExpiresAt)
                }</span>

                <span class="cov0" title="0">if status.UserEmail != nil </span><span class="cov0" title="0">{
                        fmt.Printf("User: %s\n", *status.UserEmail)
                }</span>

                <span class="cov0" title="0">if status.TokensUsed != nil &amp;&amp; status.MaxTokens != nil </span><span class="cov0" title="0">{
                        fmt.Printf("Token Usage: %d/%d\n", *status.TokensUsed, *status.MaxTokens)
                }</span>

                <span class="cov0" title="0">if !status.Valid </span><span class="cov0" title="0">{
                        fmt.Println("\nContact your administrator for license assistance.")
                        os.Exit(1)
                }</span>
        },
}

// License portal command
// License portal command removed - customers should contact administrator for license assistance

func init() <span class="cov0" title="0">{
        // Add config subcommands
        configCmd.AddCommand(configShowCmd)
        configCmd.AddCommand(configEnvCmd)
        configCmd.AddCommand(configGenerateCmd)

        // Add license subcommands
        licenseCmd.AddCommand(licenseStatusCmd)
        // License portal command removed - customers should contact administrator
}</pre>
		
		<pre class="file" id="file1" style="display: none">package client

import (
        "bytes"
        "context"
        "crypto/tls"
        "crypto/x509"
        "encoding/json"
        "fmt"
        "io"
        "log"
        "net"
        "net/http"
        "net/url"
        "os"
        "regexp"
        "strings"
        "time"
)

var (
        // DNS label validation regex (RFC 1035)
        // - Labels must start with a letter or digit
        // - Can contain letters, digits, and hyphens
        // - Cannot end with a hyphen
        // - Max 63 characters per label
        dnsLabelRegex = regexp.MustCompile(`^[a-zA-Z0-9]([a-zA-Z0-9\-]{0,61}[a-zA-Z0-9])?$`)
        
        // Valid DNS record types
        validRecordTypes = map[string]bool{
                "A":     true,
                "AAAA":  true,
                "CNAME": true,
                "MX":    true,
                "TXT":   true,
                "NS":    true,
                "SOA":   true,
                "PTR":   true,
                "SRV":   true,
                "CAA":   true,
                "DNSKEY": true,
                "DS":    true,
                "NAPTR": true,
                "SSHFP": true,
                "TLSA":  true,
                "ANY":   true,
        }
)

// validateDNSName validates a DNS domain name according to RFC 1035
func validateDNSName(domain string) error <span class="cov0" title="0">{
        // Check overall length (max 253 characters)
        if len(domain) == 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("DNS name cannot be empty")
        }</span>
        <span class="cov0" title="0">if len(domain) &gt; 253 </span><span class="cov0" title="0">{
                return fmt.Errorf("DNS name too long: %d characters (max 253)", len(domain))
        }</span>
        
        // Remove trailing dot if present (valid in DNS but we'll validate without it)
        <span class="cov0" title="0">domain = strings.TrimSuffix(domain, ".")
        
        // Check for invalid characters at the domain level
        if strings.ContainsAny(domain, " !@#$%^&amp;*()+={}[]|\\:;\"'&lt;&gt;,?/`~") </span><span class="cov0" title="0">{
                return fmt.Errorf("DNS name contains invalid characters")
        }</span>
        
        // Split into labels and validate each
        <span class="cov0" title="0">labels := strings.Split(domain, ".")
        if len(labels) == 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("DNS name has no labels")
        }</span>
        
        <span class="cov0" title="0">for i, label := range labels </span><span class="cov0" title="0">{
                // Check label length (max 63 characters)
                if len(label) == 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("DNS name contains empty label at position %d", i)
                }</span>
                <span class="cov0" title="0">if len(label) &gt; 63 </span><span class="cov0" title="0">{
                        return fmt.Errorf("DNS label '%s' too long: %d characters (max 63)", label, len(label))
                }</span>
                
                // Special case: TLD can be all numeric for reverse DNS (e.g., "1.0.0.127.in-addr.arpa")
                <span class="cov0" title="0">if i == len(labels)-1 &amp;&amp; label == "arpa" </span><span class="cov0" title="0">{
                        continue</span> // Skip validation for .arpa TLD
                }
                
                // Check label format
                <span class="cov0" title="0">if !dnsLabelRegex.MatchString(label) </span><span class="cov0" title="0">{
                        // Special case for IDN/punycode domains
                        if strings.HasPrefix(label, "xn--") </span><span class="cov0" title="0">{
                                continue</span> // Skip validation for punycode labels
                        }
                        <span class="cov0" title="0">return fmt.Errorf("invalid DNS label '%s': must start/end with alphanumeric and contain only letters, digits, and hyphens", label)</span>
                }
                
                // Check for consecutive hyphens (sometimes indicates typos)
                <span class="cov0" title="0">if strings.Contains(label, "--") &amp;&amp; !strings.HasPrefix(label, "xn--") </span><span class="cov0" title="0">{
                        // Allow -- only in punycode domains
                        return fmt.Errorf("invalid DNS label '%s': contains consecutive hyphens", label)
                }</span>
        }
        
        <span class="cov0" title="0">return nil</span>
}

// validateRecordType validates DNS record type
func validateRecordType(recordType string) error <span class="cov0" title="0">{
        recordType = strings.ToUpper(recordType)
        if !validRecordTypes[recordType] </span><span class="cov0" title="0">{
                validTypes := make([]string, 0, len(validRecordTypes))
                for t := range validRecordTypes </span><span class="cov0" title="0">{
                        validTypes = append(validTypes, t)
                }</span>
                <span class="cov0" title="0">return fmt.Errorf("invalid DNS record type '%s': must be one of %v", recordType, validTypes)</span>
        }
        <span class="cov0" title="0">return nil</span>
}

// DoHClient represents a DNS-over-HTTPS client with mTLS support
type DoHClient struct {
        serverURLs   []string
        authToken    string
        clientCert   string
        clientKey    string
        caCert       string
        verifySSL    bool
        httpClient   *http.Client
        timeout      time.Duration
        maxRetries   int
        retryDelay   time.Duration
        currentIndex int // Track which server we're currently using
}

// Config holds the configuration for the DoH client
type Config struct {
        ServerURL   string   `yaml:"server_url" json:"server_url"`
        ServerURLs  []string `yaml:"server_urls" json:"server_urls"`
        AuthToken   string   `yaml:"auth_token" json:"auth_token"`
        ClientCert  string   `yaml:"client_cert" json:"client_cert"`
        ClientKey   string   `yaml:"client_key" json:"client_key"`
        CaCert      string   `yaml:"ca_cert" json:"ca_cert"`
        VerifySSL   bool     `yaml:"verify_ssl" json:"verify_ssl"`
        MaxRetries  int      `yaml:"max_retries" json:"max_retries"`
        RetryDelay  int      `yaml:"retry_delay" json:"retry_delay"` // seconds
}

// DNSResponse represents a DNS-over-HTTPS JSON response
type DNSResponse struct {
        Status   int         `json:"Status"`
        TC       bool        `json:"TC"`
        RD       bool        `json:"RD"`
        RA       bool        `json:"RA"`
        AD       bool        `json:"AD"`
        CD       bool        `json:"CD"`
        Question []DNSRecord `json:"Question,omitempty"`
        Answer   []DNSRecord `json:"Answer,omitempty"`
        Comment  string      `json:"Comment,omitempty"`
        TTL      int         `json:"TTL,omitempty"`
}

// DNSRecord represents a DNS record in the JSON response
type DNSRecord struct {
        Name string `json:"name"`
        Type int    `json:"type"`
        TTL  int    `json:"TTL,omitempty"`
        Data string `json:"data"`
}

// validateServerURL ensures the server URL uses an IP address to prevent DNS loops
func validateServerURL(serverURL string) error <span class="cov0" title="0">{
        if serverURL == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("server URL cannot be empty")
        }</span>

        <span class="cov0" title="0">parsedURL, err := url.Parse(serverURL)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid server URL format: %w", err)
        }</span>

        <span class="cov0" title="0">if parsedURL.Scheme != "https" &amp;&amp; parsedURL.Scheme != "http" </span><span class="cov0" title="0">{
                return fmt.Errorf("server URL must use http or https scheme, got: %s", parsedURL.Scheme)
        }</span>

        <span class="cov0" title="0">host := parsedURL.Hostname()
        if host == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("server URL must include a host")
        }</span>

        // Check if the host is an IP address (IPv4 or IPv6)
        <span class="cov0" title="0">if net.ParseIP(host) == nil </span><span class="cov0" title="0">{
                // Special case: allow localhost for development
                if strings.ToLower(host) == "localhost" </span><span class="cov0" title="0">{
                        return nil
                }</span>
                
                // Special case: allow well-known public DNS providers to prevent breaking existing configs
                <span class="cov0" title="0">allowedHosts := []string{
                        "dns.google",
                        "dns.google.com", // Legacy Google DNS domain
                        "cloudflare-dns.com",
                        "1.1.1.1", // Cloudflare primary
                        "1.0.0.1", // Cloudflare secondary
                        "dns.quad9.net",
                        "dns.opendns.com",
                        "doh.opendns.com",
                        "dns.nextdns.io",
                        "doh.cleanbrowsing.org",
                }
                
                hostLower := strings.ToLower(host)
                for _, allowed := range allowedHosts </span><span class="cov0" title="0">{
                        if hostLower == allowed || strings.HasPrefix(hostLower, allowed + ".") </span><span class="cov0" title="0">{
                                // Don't show warning for public DNS providers
                                if !strings.Contains(hostLower, "google") &amp;&amp; !strings.Contains(hostLower, "cloudflare") &amp;&amp;
                                   !strings.Contains(hostLower, "1.1.1.1") &amp;&amp; !strings.Contains(hostLower, "1.0.0.1") </span><span class="cov0" title="0">{
                                        fmt.Printf("INFO: Using public DNS provider '%s'\n", host)
                                }</span>
                                <span class="cov0" title="0">return nil</span>
                        }
                }
                
                <span class="cov0" title="0">return fmt.Errorf("server URL must use an IP address (not hostname '%s') to prevent DNS resolution loops. Use the IP address of your DNS server instead", host)</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// NewDoHClient creates a new DNS-over-HTTPS client
func NewDoHClient(config *Config) (*DoHClient, error) <span class="cov0" title="0">{
        if config == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("config cannot be nil")
        }</span>

        // Build server URLs list (prioritize ServerURLs over ServerURL)
        <span class="cov0" title="0">var serverURLs []string
        if len(config.ServerURLs) &gt; 0 </span><span class="cov0" title="0">{
                serverURLs = config.ServerURLs
        }</span> else<span class="cov0" title="0"> if config.ServerURL != "" </span><span class="cov0" title="0">{
                serverURLs = []string{config.ServerURL}
        }</span> else<span class="cov0" title="0"> {
                return nil, fmt.Errorf("no server URLs provided")
        }</span>

        // Validate and normalize all server URLs
        <span class="cov0" title="0">for i, serverURL := range serverURLs </span><span class="cov0" title="0">{
                if err := validateServerURL(serverURL); err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("invalid server URL at index %d: %w", i, err)
                }</span>
                // Normalize URLs for known public DNS providers
                <span class="cov0" title="0">serverURLs[i] = normalizeServerURL(serverURL)</span>
        }

        // Set defaults
        <span class="cov0" title="0">maxRetries := config.MaxRetries
        if maxRetries &lt;= 0 </span><span class="cov0" title="0">{
                maxRetries = len(serverURLs) * 2 // Default: try each server twice
        }</span>

        <span class="cov0" title="0">retryDelay := time.Duration(config.RetryDelay) * time.Second
        if retryDelay &lt;= 0 </span><span class="cov0" title="0">{
                retryDelay = 2 * time.Second // Default: 2 second delay between retries
        }</span>

        <span class="cov0" title="0">client := &amp;DoHClient{
                serverURLs:   serverURLs,
                authToken:    config.AuthToken,
                clientCert:   config.ClientCert,
                clientKey:    config.ClientKey,
                caCert:       config.CaCert,
                verifySSL:    config.VerifySSL,
                timeout:      30 * time.Second,
                maxRetries:   maxRetries,
                retryDelay:   retryDelay,
                currentIndex: 0,
        }

        if err := client.setupHTTPClient(); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to setup HTTP client: %w", err)
        }</span>

        <span class="cov0" title="0">return client, nil</span>
}

// setupHTTPClient configures the HTTP client with mTLS support
func (c *DoHClient) setupHTTPClient() error <span class="cov0" title="0">{
        tlsConfig := &amp;tls.Config{
                // #nosec G402 - InsecureSkipVerify is controlled by verifySSL config option
                // When verifySSL is true (default), this becomes false (secure)  
                // When verifySSL is false (user choice), this becomes true (for testing only)
                InsecureSkipVerify: !c.verifySSL,
        }

        // Load CA certificate for server verification
        if c.caCert != "" &amp;&amp; c.verifySSL </span><span class="cov0" title="0">{
                caCertData, err := os.ReadFile(c.caCert)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to read CA certificate: %w", err)
                }</span>

                <span class="cov0" title="0">caCertPool := x509.NewCertPool()
                if !caCertPool.AppendCertsFromPEM(caCertData) </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to parse CA certificate")
                }</span>
                <span class="cov0" title="0">tlsConfig.RootCAs = caCertPool</span>
        }

        // Load client certificate for mTLS
        <span class="cov0" title="0">if c.clientCert != "" &amp;&amp; c.clientKey != "" </span><span class="cov0" title="0">{
                if _, err := os.Stat(c.clientCert); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("client certificate not found: %w", err)
                }</span>
                <span class="cov0" title="0">if _, err := os.Stat(c.clientKey); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("client key not found: %w", err)
                }</span>

                <span class="cov0" title="0">cert, err := tls.LoadX509KeyPair(c.clientCert, c.clientKey)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to load client certificate: %w", err)
                }</span>
                <span class="cov0" title="0">tlsConfig.Certificates = []tls.Certificate{cert}</span>
        }

        <span class="cov0" title="0">transport := &amp;http.Transport{
                TLSClientConfig: tlsConfig,
                MaxIdleConns:    10,
                IdleConnTimeout: 30 * time.Second,
        }

        c.httpClient = &amp;http.Client{
                Transport: transport,
                Timeout:   c.timeout,
        }

        return nil</span>
}

// Query performs a DNS query using DNS-over-HTTPS with automatic failover
func (c *DoHClient) Query(ctx context.Context, domain, recordType string) (*DNSResponse, error) <span class="cov0" title="0">{
        // Validate DNS name
        if err := validateDNSName(domain); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid domain name: %w", err)
        }</span>
        
        // Validate and normalize record type
        <span class="cov0" title="0">if recordType == "" </span><span class="cov0" title="0">{
                recordType = "A"
        }</span>
        <span class="cov0" title="0">recordType = strings.ToUpper(recordType)
        if err := validateRecordType(recordType); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">var lastErr error
        var errors []string

        // Try each server with retry logic
        for attempt := 0; attempt &lt; c.maxRetries; attempt++ </span><span class="cov0" title="0">{
                serverURL := c.serverURLs[c.currentIndex]
                
                // Build request URL with query parameters
                req, err := http.NewRequestWithContext(ctx, "GET", serverURL, nil)
                if err != nil </span><span class="cov0" title="0">{
                        lastErr = fmt.Errorf("failed to create request for %s: %w", serverURL, err)
                        errors = append(errors, lastErr.Error())
                        c.nextServer()
                        continue</span>
                }

                // Add query parameters
                <span class="cov0" title="0">q := req.URL.Query()
                q.Add("name", domain)
                q.Add("type", recordType)
                req.URL.RawQuery = q.Encode()

                // Set headers
                req.Header.Set("Accept", "application/dns-json")
                req.Header.Set("User-Agent", "Squawk DNS Client (Go/1.0)")

                // Add authentication header if token is provided
                if c.authToken != "" </span><span class="cov0" title="0">{
                        req.Header.Set("Authorization", "Bearer "+c.authToken)
                }</span>

                // Execute request
                <span class="cov0" title="0">resp, err := c.httpClient.Do(req)
                if err != nil </span><span class="cov0" title="0">{
                        lastErr = fmt.Errorf("HTTP request failed for %s: %w", serverURL, err)
                        errors = append(errors, lastErr.Error())
                        c.nextServer()
                        
                        // Add delay before next attempt
                        if attempt &lt; c.maxRetries-1 </span><span class="cov0" title="0">{
                                select </span>{
                                case &lt;-ctx.Done():<span class="cov0" title="0">
                                        return nil, ctx.Err()</span>
                                case &lt;-time.After(c.retryDelay):<span class="cov0" title="0"></span>
                                }
                        }
                        <span class="cov0" title="0">continue</span>
                }
                <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{
                        if err := resp.Body.Close(); err != nil </span><span class="cov0" title="0">{
                                log.Printf("Warning: failed to close response body: %v", err)
                        }</span>
                }()

                // Read response body
                <span class="cov0" title="0">body, err := io.ReadAll(resp.Body)
                if err != nil </span><span class="cov0" title="0">{
                        lastErr = fmt.Errorf("failed to read response body from %s: %w", serverURL, err)
                        errors = append(errors, lastErr.Error())
                        c.nextServer()
                        continue</span>
                }

                // Check status code
                <span class="cov0" title="0">if resp.StatusCode != http.StatusOK </span><span class="cov0" title="0">{
                        lastErr = fmt.Errorf("HTTP %d from %s: %s", resp.StatusCode, serverURL, string(body))
                        errors = append(errors, lastErr.Error())
                        c.nextServer()
                        continue</span>
                }

                // Parse JSON response
                <span class="cov0" title="0">var dnsResp DNSResponse
                if err := json.Unmarshal(body, &amp;dnsResp); err != nil </span><span class="cov0" title="0">{
                        lastErr = fmt.Errorf("failed to parse DNS response from %s: %w", serverURL, err)
                        errors = append(errors, lastErr.Error())
                        c.nextServer()
                        continue</span>
                }

                // Success! Return the response
                <span class="cov0" title="0">return &amp;dnsResp, nil</span>
        }

        // All servers failed, return combined error
        <span class="cov0" title="0">if len(errors) &gt; 1 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("all DNS servers failed after %d attempts: %s", c.maxRetries, strings.Join(errors, "; "))
        }</span>
        
        <span class="cov0" title="0">return nil, fmt.Errorf("DNS query failed: %w", lastErr)</span>
}

// nextServer advances to the next server in the list (round-robin)
func (c *DoHClient) nextServer() <span class="cov0" title="0">{
        c.currentIndex = (c.currentIndex + 1) % len(c.serverURLs)
}</span>

// normalizeServerURL ensures the server URL has the correct path for known providers
func normalizeServerURL(serverURL string) string <span class="cov0" title="0">{
        parsedURL, err := url.Parse(serverURL)
        if err != nil </span><span class="cov0" title="0">{
                return serverURL
        }</span>
        
        <span class="cov0" title="0">host := strings.ToLower(parsedURL.Hostname())
        
        // Google DNS - ensure correct path
        if strings.Contains(host, "dns.google") </span><span class="cov0" title="0">{
                if parsedURL.Path == "" || parsedURL.Path == "/" </span><span class="cov0" title="0">{
                        parsedURL.Path = "/resolve"
                }</span>
        }
        
        // Cloudflare DNS - ensure correct path
        <span class="cov0" title="0">if strings.Contains(host, "cloudflare") || host == "1.1.1.1" || host == "1.0.0.1" </span><span class="cov0" title="0">{
                if parsedURL.Path == "" || parsedURL.Path == "/" </span><span class="cov0" title="0">{
                        parsedURL.Path = "/dns-query"
                }</span>
        }
        
        // Quad9 DNS
        <span class="cov0" title="0">if strings.Contains(host, "dns.quad9.net") </span><span class="cov0" title="0">{
                if parsedURL.Path == "" || parsedURL.Path == "/" </span><span class="cov0" title="0">{
                        parsedURL.Path = "/dns-query"
                }</span>
        }
        
        <span class="cov0" title="0">return parsedURL.String()</span>
}

// QueryWithJSON performs a DNS query using POST with JSON payload
func (c *DoHClient) QueryWithJSON(ctx context.Context, domain, recordType string) (*DNSResponse, error) <span class="cov0" title="0">{
        // Validate DNS name
        if err := validateDNSName(domain); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid domain name: %w", err)
        }</span>
        
        // Validate and normalize record type
        <span class="cov0" title="0">if recordType == "" </span><span class="cov0" title="0">{
                recordType = "A"
        }</span>
        <span class="cov0" title="0">recordType = strings.ToUpper(recordType)
        if err := validateRecordType(recordType); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Create JSON payload
        <span class="cov0" title="0">payload := map[string]interface{}{
                "name": domain,
                "type": recordType,
        }

        jsonData, err := json.Marshal(payload)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to marshal JSON: %w", err)
        }</span>

        // Create POST request
        // Use the current server URL (same as Query method)
        <span class="cov0" title="0">if len(c.serverURLs) == 0 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("no server URLs configured")
        }</span>
        <span class="cov0" title="0">serverURL := c.serverURLs[c.currentIndex]
        req, err := http.NewRequestWithContext(ctx, "POST", serverURL, bytes.NewBuffer(jsonData))
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create request: %w", err)
        }</span>

        // Set headers
        <span class="cov0" title="0">req.Header.Set("Content-Type", "application/json")
        req.Header.Set("Accept", "application/dns-json")
        req.Header.Set("User-Agent", "Squawk DNS Client (Go/1.0)")

        // Add authentication header if token is provided
        if c.authToken != "" </span><span class="cov0" title="0">{
                req.Header.Set("Authorization", "Bearer "+c.authToken)
        }</span>

        // Execute request
        <span class="cov0" title="0">resp, err := c.httpClient.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("HTTP request failed: %w", err)
        }</span>
        <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{
                if err := resp.Body.Close(); err != nil </span><span class="cov0" title="0">{
                        log.Printf("Warning: failed to close response body: %v", err)
                }</span>
        }()

        // Read response body
        <span class="cov0" title="0">body, err := io.ReadAll(resp.Body)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to read response body: %w", err)
        }</span>

        // Check status code
        <span class="cov0" title="0">if resp.StatusCode != http.StatusOK </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("HTTP %d: %s", resp.StatusCode, string(body))
        }</span>

        // Parse JSON response
        <span class="cov0" title="0">var dnsResp DNSResponse
        if err := json.Unmarshal(body, &amp;dnsResp); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to parse DNS response: %w", err)
        }</span>

        <span class="cov0" title="0">return &amp;dnsResp, nil</span>
}

// SetTimeout sets the HTTP client timeout
func (c *DoHClient) SetTimeout(timeout time.Duration) <span class="cov0" title="0">{
        c.timeout = timeout
        if c.httpClient != nil </span><span class="cov0" title="0">{
                c.httpClient.Timeout = timeout
        }</span>
}

// Close cleans up the HTTP client resources
func (c *DoHClient) Close() error <span class="cov0" title="0">{
        if c.httpClient != nil </span><span class="cov0" title="0">{
                c.httpClient.CloseIdleConnections()
        }</span>
        <span class="cov0" title="0">return nil</span>
}</pre>
		
		<pre class="file" id="file2" style="display: none">package config

import (
        "fmt"
        "os"
        "strconv"
        "strings"

        "github.com/penguincloud/squawk/dns-client-go/pkg/client"
        "github.com/penguincloud/squawk/dns-client-go/pkg/forwarder"
        "github.com/spf13/viper"
        "gopkg.in/yaml.v3"
)

// LicenseConfig holds license validation configuration
type LicenseConfig struct {
        ServerURL      string `yaml:"server_url" json:"server_url"`
        LicenseKey     string `yaml:"license_key" json:"license_key"`
        UserToken      string `yaml:"user_token" json:"user_token"`
        ValidateOnline bool   `yaml:"validate_online" json:"validate_online"`
        CacheTime      int    `yaml:"cache_time" json:"cache_time"` // minutes
}

// AppConfig holds the complete application configuration
type AppConfig struct {
        Domain       string                `yaml:"domain" json:"domain"`
        RecordType   string                `yaml:"record_type" json:"record_type"`
        Client       *client.Config        `yaml:"client" json:"client"`
        Forwarder    *forwarder.Config     `yaml:"forwarder" json:"forwarder"`
        License      *LicenseConfig        `yaml:"license" json:"license"`
        LogLevel     string                `yaml:"log_level" json:"log_level"`
}

// DefaultConfig returns a configuration with sensible defaults
func DefaultConfig() *AppConfig <span class="cov0" title="0">{
        return &amp;AppConfig{
                Domain:     "",
                RecordType: "A",
                LogLevel:   "INFO",
                Client: &amp;client.Config{
                        ServerURL:   "https://dns.google/resolve",
                        ServerURLs:  []string{},
                        AuthToken:   "",
                        ClientCert:  "",
                        ClientKey:   "",
                        CaCert:      "",
                        VerifySSL:   true,
                        MaxRetries:  0, // Will be set to len(servers) * 2 by default
                        RetryDelay:  2, // seconds
                },
                Forwarder: &amp;forwarder.Config{
                        UDPAddress: "127.0.0.1:53",
                        TCPAddress: "127.0.0.1:53",
                        ListenUDP:  false,
                        ListenTCP:  false,
                },
                License: &amp;LicenseConfig{
                        ServerURL:      "https://license.squawkdns.com",
                        LicenseKey:     "",
                        UserToken:      "",
                        ValidateOnline: true,
                        CacheTime:      1440, // 24 hours (daily validation)
                },
        }
}</span>

// LoadConfig loads configuration from file, environment variables, and defaults
func LoadConfig(configFile string) (*AppConfig, error) <span class="cov0" title="0">{
        config := DefaultConfig()

        // Load from config file if provided
        if configFile != "" </span><span class="cov0" title="0">{
                if err := loadFromFile(configFile, config); err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to load config file: %w", err)
                }</span>
        }

        // Override with environment variables
        <span class="cov0" title="0">loadFromEnv(config)

        // Validate configuration
        if err := validateConfig(config); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid configuration: %w", err)
        }</span>

        <span class="cov0" title="0">return config, nil</span>
}

// loadFromFile loads configuration from a YAML file
func loadFromFile(filename string, config *AppConfig) error <span class="cov0" title="0">{
        // Validate filename to prevent directory traversal attacks
        if strings.Contains(filename, "..") </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid filename: directory traversal not allowed")
        }</span>
        
        // #nosec G304 - This reads user-specified config files, validated against directory traversal
        <span class="cov0" title="0">data, err := os.ReadFile(filename)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to read config file: %w", err)
        }</span>

        <span class="cov0" title="0">if err := yaml.Unmarshal(data, config); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to parse config file: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// loadFromEnv loads configuration from environment variables
func loadFromEnv(config *AppConfig) <span class="cov0" title="0">{
        // Initialize viper for environment variable handling
        viper.AutomaticEnv()
        viper.SetEnvKeyReplacer(strings.NewReplacer(".", "_"))

        // Main configuration
        if domain := os.Getenv("SQUAWK_DOMAIN"); domain != "" </span><span class="cov0" title="0">{
                config.Domain = domain
        }</span>
        <span class="cov0" title="0">if recordType := os.Getenv("SQUAWK_RECORD_TYPE"); recordType != "" </span><span class="cov0" title="0">{
                config.RecordType = recordType
        }</span>
        <span class="cov0" title="0">if logLevel := os.Getenv("LOG_LEVEL"); logLevel != "" </span><span class="cov0" title="0">{
                config.LogLevel = logLevel
        }</span>

        // Client configuration
        <span class="cov0" title="0">if serverURL := os.Getenv("SQUAWK_SERVER_URL"); serverURL != "" </span><span class="cov0" title="0">{
                config.Client.ServerURL = serverURL
        }</span>
        
        // Multiple server URLs (comma-separated)
        <span class="cov0" title="0">if serverURLs := os.Getenv("SQUAWK_SERVER_URLS"); serverURLs != "" </span><span class="cov0" title="0">{
                urls := strings.Split(serverURLs, ",")
                for i, url := range urls </span><span class="cov0" title="0">{
                        urls[i] = strings.TrimSpace(url)
                }</span>
                <span class="cov0" title="0">config.Client.ServerURLs = urls</span>
        }
        
        // Retry configuration
        <span class="cov0" title="0">if maxRetries := os.Getenv("SQUAWK_MAX_RETRIES"); maxRetries != "" </span><span class="cov0" title="0">{
                if retries, err := strconv.Atoi(maxRetries); err == nil &amp;&amp; retries &gt; 0 </span><span class="cov0" title="0">{
                        config.Client.MaxRetries = retries
                }</span>
        }
        
        <span class="cov0" title="0">if retryDelay := os.Getenv("SQUAWK_RETRY_DELAY"); retryDelay != "" </span><span class="cov0" title="0">{
                if delay, err := strconv.Atoi(retryDelay); err == nil &amp;&amp; delay &gt; 0 </span><span class="cov0" title="0">{
                        config.Client.RetryDelay = delay
                }</span>
        }
        <span class="cov0" title="0">if authToken := os.Getenv("SQUAWK_AUTH_TOKEN"); authToken != "" </span><span class="cov0" title="0">{
                config.Client.AuthToken = authToken
        }</span>
        <span class="cov0" title="0">if clientCert := os.Getenv("SQUAWK_CLIENT_CERT"); clientCert != "" </span><span class="cov0" title="0">{
                config.Client.ClientCert = clientCert
        }</span>
        // Support legacy environment variable names
        <span class="cov0" title="0">if clientCert := os.Getenv("CLIENT_CERT_PATH"); clientCert != "" </span><span class="cov0" title="0">{
                config.Client.ClientCert = clientCert
        }</span>
        
        <span class="cov0" title="0">if clientKey := os.Getenv("SQUAWK_CLIENT_KEY"); clientKey != "" </span><span class="cov0" title="0">{
                config.Client.ClientKey = clientKey
        }</span>
        // Support legacy environment variable names
        <span class="cov0" title="0">if clientKey := os.Getenv("CLIENT_KEY_PATH"); clientKey != "" </span><span class="cov0" title="0">{
                config.Client.ClientKey = clientKey
        }</span>
        
        <span class="cov0" title="0">if caCert := os.Getenv("SQUAWK_CA_CERT"); caCert != "" </span><span class="cov0" title="0">{
                config.Client.CaCert = caCert
        }</span>
        // Support legacy environment variable names
        <span class="cov0" title="0">if caCert := os.Getenv("CA_CERT_PATH"); caCert != "" </span><span class="cov0" title="0">{
                config.Client.CaCert = caCert
        }</span>
        
        <span class="cov0" title="0">if verifySSL := os.Getenv("SQUAWK_VERIFY_SSL"); verifySSL != "" </span><span class="cov0" title="0">{
                if val, err := strconv.ParseBool(verifySSL); err == nil </span><span class="cov0" title="0">{
                        config.Client.VerifySSL = val
                }</span>
        }

        // Forwarder configuration
        <span class="cov0" title="0">if udpAddr := os.Getenv("SQUAWK_UDP_ADDRESS"); udpAddr != "" </span><span class="cov0" title="0">{
                config.Forwarder.UDPAddress = udpAddr
        }</span>
        <span class="cov0" title="0">if tcpAddr := os.Getenv("SQUAWK_TCP_ADDRESS"); tcpAddr != "" </span><span class="cov0" title="0">{
                config.Forwarder.TCPAddress = tcpAddr
        }</span>
        <span class="cov0" title="0">if listenUDP := os.Getenv("SQUAWK_LISTEN_UDP"); listenUDP != "" </span><span class="cov0" title="0">{
                if val, err := strconv.ParseBool(listenUDP); err == nil </span><span class="cov0" title="0">{
                        config.Forwarder.ListenUDP = val
                }</span>
        }
        <span class="cov0" title="0">if listenTCP := os.Getenv("SQUAWK_LISTEN_TCP"); listenTCP != "" </span><span class="cov0" title="0">{
                if val, err := strconv.ParseBool(listenTCP); err == nil </span><span class="cov0" title="0">{
                        config.Forwarder.ListenTCP = val
                }</span>
        }

        // License configuration
        <span class="cov0" title="0">if licenseServerURL := os.Getenv("SQUAWK_LICENSE_SERVER_URL"); licenseServerURL != "" </span><span class="cov0" title="0">{
                config.License.ServerURL = licenseServerURL
        }</span>
        <span class="cov0" title="0">if licenseKey := os.Getenv("SQUAWK_LICENSE_KEY"); licenseKey != "" </span><span class="cov0" title="0">{
                config.License.LicenseKey = licenseKey
        }</span>
        <span class="cov0" title="0">if userToken := os.Getenv("SQUAWK_USER_TOKEN"); userToken != "" </span><span class="cov0" title="0">{
                config.License.UserToken = userToken
        }</span>
        <span class="cov0" title="0">if validateOnline := os.Getenv("SQUAWK_VALIDATE_ONLINE"); validateOnline != "" </span><span class="cov0" title="0">{
                if val, err := strconv.ParseBool(validateOnline); err == nil </span><span class="cov0" title="0">{
                        config.License.ValidateOnline = val
                }</span>
        }
        <span class="cov0" title="0">if cacheTime := os.Getenv("SQUAWK_LICENSE_CACHE_TIME"); cacheTime != "" </span><span class="cov0" title="0">{
                if val, err := strconv.Atoi(cacheTime); err == nil &amp;&amp; val &gt; 0 </span><span class="cov0" title="0">{
                        config.License.CacheTime = val
                }</span>
        }
}

// validateConfig validates the configuration
func validateConfig(config *AppConfig) error <span class="cov0" title="0">{
        if config == nil </span><span class="cov0" title="0">{
                return fmt.Errorf("configuration is nil")
        }</span>

        <span class="cov0" title="0">if config.Client == nil </span><span class="cov0" title="0">{
                return fmt.Errorf("client configuration is required")
        }</span>

        <span class="cov0" title="0">if config.Client.ServerURL == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("server URL is required")
        }</span>

        // Validate mTLS configuration
        <span class="cov0" title="0">if config.Client.ClientCert != "" &amp;&amp; config.Client.ClientKey == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("client key is required when client certificate is provided")
        }</span>
        <span class="cov0" title="0">if config.Client.ClientKey != "" &amp;&amp; config.Client.ClientCert == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("client certificate is required when client key is provided")
        }</span>

        // Check if certificate files exist
        <span class="cov0" title="0">if config.Client.ClientCert != "" </span><span class="cov0" title="0">{
                if _, err := os.Stat(config.Client.ClientCert); os.IsNotExist(err) </span><span class="cov0" title="0">{
                        return fmt.Errorf("client certificate file not found: %s", config.Client.ClientCert)
                }</span>
        }
        <span class="cov0" title="0">if config.Client.ClientKey != "" </span><span class="cov0" title="0">{
                if _, err := os.Stat(config.Client.ClientKey); os.IsNotExist(err) </span><span class="cov0" title="0">{
                        return fmt.Errorf("client key file not found: %s", config.Client.ClientKey)
                }</span>
        }
        <span class="cov0" title="0">if config.Client.CaCert != "" </span><span class="cov0" title="0">{
                if _, err := os.Stat(config.Client.CaCert); os.IsNotExist(err) </span><span class="cov0" title="0">{
                        return fmt.Errorf("CA certificate file not found: %s", config.Client.CaCert)
                }</span>
        }

        // License validation
        <span class="cov0" title="0">if config.License == nil </span><span class="cov0" title="0">{
                return fmt.Errorf("license configuration is required")
        }</span>

        // License is required for premium features (warn but don't fail for backward compatibility)
        <span class="cov0" title="0">if config.License.LicenseKey == "" &amp;&amp; config.License.UserToken == "" </span>{<span class="cov0" title="0">
                // This will be handled at runtime with appropriate warnings
                // allowing backward compatibility for users without licenses
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// SaveConfig saves the configuration to a YAML file
func SaveConfig(config *AppConfig, filename string) error <span class="cov0" title="0">{
        data, err := yaml.Marshal(config)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to marshal config: %w", err)
        }</span>

        <span class="cov0" title="0">if err := os.WriteFile(filename, data, 0600); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to write config file: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// GetEnvVarList returns a list of all supported environment variables
func GetEnvVarList() []string <span class="cov0" title="0">{
        return []string{
                "SQUAWK_DOMAIN",
                "SQUAWK_RECORD_TYPE", 
                "SQUAWK_SERVER_URL",
                "SQUAWK_SERVER_URLS",
                "SQUAWK_MAX_RETRIES", 
                "SQUAWK_RETRY_DELAY",
                "SQUAWK_AUTH_TOKEN",
                "SQUAWK_CLIENT_CERT",
                "SQUAWK_CLIENT_KEY",
                "SQUAWK_CA_CERT",
                "SQUAWK_VERIFY_SSL",
                "SQUAWK_UDP_ADDRESS",
                "SQUAWK_TCP_ADDRESS", 
                "SQUAWK_LISTEN_UDP",
                "SQUAWK_LISTEN_TCP",
                "SQUAWK_LICENSE_SERVER_URL",
                "SQUAWK_LICENSE_KEY",
                "SQUAWK_USER_TOKEN",
                "SQUAWK_VALIDATE_ONLINE",
                "SQUAWK_LICENSE_CACHE_TIME",
                "LOG_LEVEL",
                // Legacy support
                "CLIENT_CERT_PATH",
                "CLIENT_KEY_PATH",
                "CA_CERT_PATH",
        }
}</span>

// PrintConfig prints the configuration in a human-readable format
func (c *AppConfig) String() string <span class="cov0" title="0">{
        var sb strings.Builder
        
        sb.WriteString("Squawk DNS Client Configuration:\n")
        sb.WriteString("================================\n")
        sb.WriteString(fmt.Sprintf("Domain: %s\n", c.Domain))
        sb.WriteString(fmt.Sprintf("Record Type: %s\n", c.RecordType))
        sb.WriteString(fmt.Sprintf("Log Level: %s\n", c.LogLevel))
        sb.WriteString("\nClient Configuration:\n")
        sb.WriteString(fmt.Sprintf("  Server URL: %s\n", c.Client.ServerURL))
        sb.WriteString(fmt.Sprintf("  Auth Token: %s\n", maskToken(c.Client.AuthToken)))
        sb.WriteString(fmt.Sprintf("  Client Cert: %s\n", c.Client.ClientCert))
        sb.WriteString(fmt.Sprintf("  Client Key: %s\n", c.Client.ClientKey))
        sb.WriteString(fmt.Sprintf("  CA Cert: %s\n", c.Client.CaCert))
        sb.WriteString(fmt.Sprintf("  Verify SSL: %t\n", c.Client.VerifySSL))
        sb.WriteString("\nForwarder Configuration:\n")
        sb.WriteString(fmt.Sprintf("  UDP Address: %s (Listen: %t)\n", c.Forwarder.UDPAddress, c.Forwarder.ListenUDP))
        sb.WriteString(fmt.Sprintf("  TCP Address: %s (Listen: %t)\n", c.Forwarder.TCPAddress, c.Forwarder.ListenTCP))
        sb.WriteString("\nLicense Configuration:\n")
        sb.WriteString(fmt.Sprintf("  Server URL: %s\n", c.License.ServerURL))
        sb.WriteString(fmt.Sprintf("  License Key: %s\n", maskToken(c.License.LicenseKey)))
        sb.WriteString(fmt.Sprintf("  User Token: %s\n", maskToken(c.License.UserToken)))
        sb.WriteString(fmt.Sprintf("  Validate Online: %t\n", c.License.ValidateOnline))
        sb.WriteString(fmt.Sprintf("  Cache Time: %d minutes\n", c.License.CacheTime))
        
        return sb.String()
}</span>

// maskToken masks the authentication token for display purposes
func maskToken(token string) string <span class="cov0" title="0">{
        if token == "" </span><span class="cov0" title="0">{
                return "(not set)"
        }</span>
        <span class="cov0" title="0">if len(token) &lt;= 8 </span><span class="cov0" title="0">{
                return strings.Repeat("*", len(token))
        }</span>
        <span class="cov0" title="0">return token[:4] + strings.Repeat("*", len(token)-8) + token[len(token)-4:]</span>
}</pre>
		
		<pre class="file" id="file3" style="display: none">package forwarder

import (
        "context"
        "fmt"
        "log"
        "net"
        "sync"
        "time"

        "github.com/miekg/dns"
        "github.com/penguincloud/squawk/dns-client-go/pkg/client"
)

// safeUint32 safely converts an int to uint32, clamping to valid range
func safeUint32(value int) uint32 <span class="cov0" title="0">{
        if value &lt; 0 </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov0" title="0">if value &gt; 0xFFFFFFFF </span><span class="cov0" title="0">{
                return 0xFFFFFFFF
        }</span>
        <span class="cov0" title="0">return uint32(value)</span>
}

// Forwarder handles DNS forwarding from traditional DNS (UDP/TCP) to DNS-over-HTTPS
type Forwarder struct {
        dohClient   *client.DoHClient
        udpAddr     string
        tcpAddr     string
        udpServer   *dns.Server
        tcpServer   *dns.Server
        listenUDP   bool
        listenTCP   bool
        running     bool
        stopCh      chan struct{}
        wg          sync.WaitGroup
        mu          sync.RWMutex
}

// Config holds the forwarder configuration
type Config struct {
        UDPAddress string `yaml:"udp_address" json:"udp_address"`
        TCPAddress string `yaml:"tcp_address" json:"tcp_address"`
        ListenUDP  bool   `yaml:"listen_udp" json:"listen_udp"`
        ListenTCP  bool   `yaml:"listen_tcp" json:"listen_tcp"`
}

// NewForwarder creates a new DNS forwarder
func NewForwarder(dohClient *client.DoHClient, config *Config) *Forwarder <span class="cov0" title="0">{
        if config == nil </span><span class="cov0" title="0">{
                config = &amp;Config{
                        UDPAddress: "127.0.0.1:53",
                        TCPAddress: "127.0.0.1:53",
                        ListenUDP:  true,
                        ListenTCP:  true,
                }
        }</span>

        <span class="cov0" title="0">return &amp;Forwarder{
                dohClient: dohClient,
                udpAddr:   config.UDPAddress,
                tcpAddr:   config.TCPAddress,
                listenUDP: config.ListenUDP,
                listenTCP: config.ListenTCP,
                stopCh:    make(chan struct{}),
        }</span>
}

// Start begins the DNS forwarding service
func (f *Forwarder) Start(ctx context.Context) error <span class="cov0" title="0">{
        f.mu.Lock()
        if f.running </span><span class="cov0" title="0">{
                f.mu.Unlock()
                return fmt.Errorf("forwarder is already running")
        }</span>
        <span class="cov0" title="0">f.running = true
        f.mu.Unlock()

        dns.HandleFunc(".", f.handleDNSRequest)

        if f.listenUDP </span><span class="cov0" title="0">{
                f.udpServer = &amp;dns.Server{
                        Addr: f.udpAddr,
                        Net:  "udp",
                }

                f.wg.Add(1)
                go func() </span><span class="cov0" title="0">{
                        defer f.wg.Done()
                        log.Printf("Starting UDP DNS forwarder on %s", f.udpAddr)
                        if err := f.udpServer.ListenAndServe(); err != nil </span><span class="cov0" title="0">{
                                log.Printf("UDP server error: %v", err)
                        }</span>
                }()
        }

        <span class="cov0" title="0">if f.listenTCP </span><span class="cov0" title="0">{
                f.tcpServer = &amp;dns.Server{
                        Addr: f.tcpAddr,
                        Net:  "tcp",
                }

                f.wg.Add(1)
                go func() </span><span class="cov0" title="0">{
                        defer f.wg.Done()
                        log.Printf("Starting TCP DNS forwarder on %s", f.tcpAddr)
                        if err := f.tcpServer.ListenAndServe(); err != nil </span><span class="cov0" title="0">{
                                log.Printf("TCP server error: %v", err)
                        }</span>
                }()
        }

        // Wait for context cancellation or stop signal
        <span class="cov0" title="0">select </span>{
        case &lt;-ctx.Done():<span class="cov0" title="0">
                return f.Stop()</span>
        case &lt;-f.stopCh:<span class="cov0" title="0">
                return nil</span>
        }
}

// Stop shuts down the DNS forwarding service
func (f *Forwarder) Stop() error <span class="cov0" title="0">{
        f.mu.Lock()
        if !f.running </span><span class="cov0" title="0">{
                f.mu.Unlock()
                return fmt.Errorf("forwarder is not running")
        }</span>
        <span class="cov0" title="0">f.running = false
        f.mu.Unlock()

        log.Println("Shutting down DNS forwarder...")

        if f.udpServer != nil </span><span class="cov0" title="0">{
                if err := f.udpServer.Shutdown(); err != nil </span><span class="cov0" title="0">{
                        log.Printf("Error shutting down UDP server: %v", err)
                }</span>
        }

        <span class="cov0" title="0">if f.tcpServer != nil </span><span class="cov0" title="0">{
                if err := f.tcpServer.Shutdown(); err != nil </span><span class="cov0" title="0">{
                        log.Printf("Error shutting down TCP server: %v", err)
                }</span>
        }

        <span class="cov0" title="0">close(f.stopCh)
        f.wg.Wait()

        log.Println("DNS forwarder stopped")
        return nil</span>
}

// handleDNSRequest processes incoming DNS requests
func (f *Forwarder) handleDNSRequest(w dns.ResponseWriter, r *dns.Msg) <span class="cov0" title="0">{
        ctx, cancel := context.WithTimeout(context.Background(), 30*time.Second)
        defer cancel()

        msg := new(dns.Msg)
        msg.SetReply(r)
        msg.Authoritative = false
        msg.RecursionAvailable = true

        // Process each question in the DNS message
        for _, q := range r.Question </span><span class="cov0" title="0">{
                // Convert DNS type to string
                qtype := dns.TypeToString[q.Qtype]
                
                log.Printf("DNS Query: %s %s from %s", q.Name, qtype, w.RemoteAddr())

                // Query via DNS-over-HTTPS
                resp, err := f.dohClient.Query(ctx, q.Name, qtype)
                if err != nil </span><span class="cov0" title="0">{
                        log.Printf("DoH query failed for %s: %v", q.Name, err)
                        msg.SetRcode(r, dns.RcodeServerFailure)
                        continue</span>
                }

                // Convert DoH response to DNS records
                <span class="cov0" title="0">if resp.Status == 0 &amp;&amp; len(resp.Answer) &gt; 0 </span><span class="cov0" title="0">{
                        for _, answer := range resp.Answer </span><span class="cov0" title="0">{
                                rr := f.convertAnswerToRR(answer, q)
                                if rr != nil </span><span class="cov0" title="0">{
                                        msg.Answer = append(msg.Answer, rr)
                                }</span>
                        }
                } else<span class="cov0" title="0"> {
                        // No answer or error status
                        if resp.Status == 3 </span><span class="cov0" title="0">{
                                msg.SetRcode(r, dns.RcodeNameError) // NXDOMAIN
                        }</span> else<span class="cov0" title="0"> {
                                msg.SetRcode(r, dns.RcodeServerFailure)
                        }</span>
                }
        }

        // Send response
        <span class="cov0" title="0">if err := w.WriteMsg(msg); err != nil </span><span class="cov0" title="0">{
                log.Printf("Failed to write DNS response: %v", err)
        }</span>
}

// convertAnswerToRR converts a DoH answer to a DNS resource record
func (f *Forwarder) convertAnswerToRR(answer client.DNSRecord, question dns.Question) dns.RR <span class="cov0" title="0">{
        // Create appropriate RR based on type
        switch question.Qtype </span>{
        case dns.TypeA:<span class="cov0" title="0">
                if ip := net.ParseIP(answer.Data); ip != nil &amp;&amp; ip.To4() != nil </span><span class="cov0" title="0">{
                        return &amp;dns.A{
                                Hdr: dns.RR_Header{
                                        Name:   question.Name,
                                        Rrtype: dns.TypeA,
                                        Class:  dns.ClassINET,
                                        Ttl:    safeUint32(answer.TTL),
                                },
                                A: ip.To4(),
                        }
                }</span>
        case dns.TypeAAAA:<span class="cov0" title="0">
                if ip := net.ParseIP(answer.Data); ip != nil &amp;&amp; ip.To16() != nil </span><span class="cov0" title="0">{
                        return &amp;dns.AAAA{
                                Hdr: dns.RR_Header{
                                        Name:   question.Name,
                                        Rrtype: dns.TypeAAAA,
                                        Class:  dns.ClassINET,
                                        Ttl:    safeUint32(answer.TTL),
                                },
                                AAAA: ip.To16(),
                        }
                }</span>
        case dns.TypeCNAME:<span class="cov0" title="0">
                return &amp;dns.CNAME{
                        Hdr: dns.RR_Header{
                                Name:   question.Name,
                                Rrtype: dns.TypeCNAME,
                                Class:  dns.ClassINET,
                                Ttl:    safeUint32(answer.TTL),
                        },
                        Target: dns.Fqdn(answer.Data),
                }</span>
        case dns.TypeMX:<span class="cov0" title="0">
                return &amp;dns.MX{
                        Hdr: dns.RR_Header{
                                Name:   question.Name,
                                Rrtype: dns.TypeMX,
                                Class:  dns.ClassINET,
                                Ttl:    safeUint32(answer.TTL),
                        },
                        Mx: dns.Fqdn(answer.Data),
                        // Priority would need to be parsed from Data if available
                }</span>
        case dns.TypeTXT:<span class="cov0" title="0">
                return &amp;dns.TXT{
                        Hdr: dns.RR_Header{
                                Name:   question.Name,
                                Rrtype: dns.TypeTXT,
                                Class:  dns.ClassINET,
                                Ttl:    safeUint32(answer.TTL),
                        },
                        Txt: []string{answer.Data},
                }</span>
        case dns.TypeNS:<span class="cov0" title="0">
                return &amp;dns.NS{
                        Hdr: dns.RR_Header{
                                Name:   question.Name,
                                Rrtype: dns.TypeNS,
                                Class:  dns.ClassINET,
                                Ttl:    safeUint32(answer.TTL),
                        },
                        Ns: dns.Fqdn(answer.Data),
                }</span>
        }

        // For unsupported types, create a generic RR
        <span class="cov0" title="0">log.Printf("Unsupported DNS type %d for answer: %s", question.Qtype, answer.Data)
        return nil</span>
}

// IsRunning returns whether the forwarder is currently running
func (f *Forwarder) IsRunning() bool <span class="cov0" title="0">{
        f.mu.RLock()
        defer f.mu.RUnlock()
        return f.running
}</pre>
		
		<pre class="file" id="file4" style="display: none">package license

import (
        "bytes"
        "context"
        "crypto/tls"
        "encoding/json"
        "fmt"
        "net/http"
        "sync"
        "time"

        "github.com/penguincloud/squawk/dns-client-go/pkg/config"
)

// ValidationResponse represents the response from license validation
type ValidationResponse struct {
        Valid         bool      `json:"valid"`
        Message       string    `json:"message"`
        ExpiresAt     *string   `json:"expires_at,omitempty"`
        TokensUsed    *int      `json:"tokens_used,omitempty"`
        MaxTokens     *int      `json:"max_tokens,omitempty"`
        UserEmail     *string   `json:"user_email,omitempty"`
        LicenseExpiry *string   `json:"license_expires,omitempty"`
}

// Validator handles license validation with caching
type Validator struct {
        config         *config.LicenseConfig
        client         *http.Client
        cache          map[string]*cacheEntry
        cacheMutex     sync.RWMutex
        lastValidate   time.Time
        dailyValidated bool
        validatedToday string // Date string YYYY-MM-DD
}

type cacheEntry struct {
        valid     bool
        expiresAt time.Time
        message   string
        validated time.Time
}

// NewValidator creates a new license validator
func NewValidator(cfg *config.LicenseConfig) *Validator <span class="cov0" title="0">{
        return &amp;Validator{
                config: cfg,
                client: &amp;http.Client{
                        Timeout: 10 * time.Second,
                        Transport: &amp;http.Transport{
                                TLSClientConfig: &amp;tls.Config{
                                        MinVersion: tls.VersionTLS12,
                                },
                        },
                },
                cache: make(map[string]*cacheEntry),
        }
}</span>

// ValidateLicense validates a license key with the license server
func (v *Validator) ValidateLicense(ctx context.Context) (*ValidationResponse, error) <span class="cov0" title="0">{
        if v.config == nil </span><span class="cov0" title="0">{
                return &amp;ValidationResponse{
                        Valid:   false,
                        Message: "License configuration not provided",
                }, fmt.Errorf("license configuration is required")
        }</span>

        <span class="cov0" title="0">today := time.Now().Format("2006-01-02")
        
        // Check if we've already validated today
        v.cacheMutex.RLock()
        if v.validatedToday == today </span><span class="cov0" title="0">{
                if entry, exists := v.cache["license_validation"]; exists </span><span class="cov0" title="0">{
                        v.cacheMutex.RUnlock()
                        return &amp;ValidationResponse{
                                Valid:   entry.valid,
                                Message: entry.message,
                        }, nil
                }</span>
        }
        <span class="cov0" title="0">v.cacheMutex.RUnlock()

        // Check cache first - use cache if less than cache time minutes old
        if !v.config.ValidateOnline </span><span class="cov0" title="0">{
                v.cacheMutex.RLock()
                if entry, exists := v.cache["license_validation"]; exists </span><span class="cov0" title="0">{
                        if time.Since(entry.validated) &lt; time.Duration(v.config.CacheTime)*time.Minute </span><span class="cov0" title="0">{
                                v.cacheMutex.RUnlock()
                                return &amp;ValidationResponse{
                                        Valid:   entry.valid,
                                        Message: entry.message,
                                }, nil
                        }</span>
                }
                <span class="cov0" title="0">v.cacheMutex.RUnlock()</span>
        }

        // Prefer user token over license key for validation
        <span class="cov0" title="0">if v.config.UserToken != "" </span><span class="cov0" title="0">{
                return v.validateUserToken(ctx)
        }</span>

        <span class="cov0" title="0">if v.config.LicenseKey != "" </span><span class="cov0" title="0">{
                return v.validateLicenseKey(ctx)
        }</span>

        <span class="cov0" title="0">return &amp;ValidationResponse{
                Valid:   false,
                Message: "No license key or user token provided",
        }, fmt.Errorf("license key or user token is required")</span>
}

// validateLicenseKey validates using license key
func (v *Validator) validateLicenseKey(ctx context.Context) (*ValidationResponse, error) <span class="cov0" title="0">{
        payload := map[string]string{
                "license_key": v.config.LicenseKey,
        }

        jsonData, err := json.Marshal(payload)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to marshal request: %w", err)
        }</span>

        <span class="cov0" title="0">req, err := http.NewRequestWithContext(ctx, "POST", v.config.ServerURL+"/api/validate", bytes.NewBuffer(jsonData))
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create request: %w", err)
        }</span>

        <span class="cov0" title="0">req.Header.Set("Content-Type", "application/json")
        req.Header.Set("User-Agent", "Squawk-DNS-Client/2.0")

        resp, err := v.client.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                return &amp;ValidationResponse{
                        Valid:   false,
                        Message: fmt.Sprintf("License server unreachable: %v", err),
                }, err
        }</span>
        <span class="cov0" title="0">defer resp.Body.Close()

        var validationResp ValidationResponse
        if err := json.NewDecoder(resp.Body).Decode(&amp;validationResp); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to decode response: %w", err)
        }</span>

        <span class="cov0" title="0">v.cacheValidation("license_validation", validationResp.Valid, validationResp.Message)
        v.lastValidate = time.Now()
        
        // Mark as validated today
        v.cacheMutex.Lock()
        v.validatedToday = time.Now().Format("2006-01-02")
        v.cacheMutex.Unlock()

        return &amp;validationResp, nil</span>
}

// validateUserToken validates using user token
func (v *Validator) validateUserToken(ctx context.Context) (*ValidationResponse, error) <span class="cov0" title="0">{
        req, err := http.NewRequestWithContext(ctx, "POST", v.config.ServerURL+"/api/validate_token", nil)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create request: %w", err)
        }</span>

        <span class="cov0" title="0">req.Header.Set("Authorization", "Bearer "+v.config.UserToken)
        req.Header.Set("User-Agent", "Squawk-DNS-Client/2.0")

        resp, err := v.client.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                return &amp;ValidationResponse{
                        Valid:   false,
                        Message: fmt.Sprintf("License server unreachable: %v", err),
                }, err
        }</span>
        <span class="cov0" title="0">defer resp.Body.Close()

        var validationResp ValidationResponse
        if err := json.NewDecoder(resp.Body).Decode(&amp;validationResp); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to decode response: %w", err)
        }</span>

        <span class="cov0" title="0">v.cacheValidation("token_validation", validationResp.Valid, validationResp.Message)
        v.lastValidate = time.Now()
        
        // Mark as validated today
        v.cacheMutex.Lock()
        v.validatedToday = time.Now().Format("2006-01-02")
        v.cacheMutex.Unlock()

        return &amp;validationResp, nil</span>
}

// cacheValidation caches validation results
func (v *Validator) cacheValidation(key string, valid bool, message string) <span class="cov0" title="0">{
        v.cacheMutex.Lock()
        defer v.cacheMutex.Unlock()

        v.cache[key] = &amp;cacheEntry{
                valid:     valid,
                expiresAt: time.Now().Add(time.Duration(v.config.CacheTime) * time.Minute),
                message:   message,
                validated: time.Now(),
        }
}</span>

// IsValid returns true if the current license/token is valid
func (v *Validator) IsValid(ctx context.Context) (bool, error) <span class="cov0" title="0">{
        today := time.Now().Format("2006-01-02")
        
        // Check if we've already validated today - use that result
        v.cacheMutex.RLock()
        if v.validatedToday == today </span><span class="cov0" title="0">{
                for _, entry := range v.cache </span><span class="cov0" title="0">{
                        if entry.valid </span><span class="cov0" title="0">{
                                v.cacheMutex.RUnlock()
                                return true, nil
                        }</span>
                }
        }
        <span class="cov0" title="0">v.cacheMutex.RUnlock()

        response, err := v.ValidateLicense(ctx)
        if err != nil </span><span class="cov0" title="0">{
                // In case of network errors, check if we have a cached valid response from today or recent
                v.cacheMutex.RLock()
                for _, entry := range v.cache </span><span class="cov0" title="0">{
                        // Allow using cache if validated within last 24 hours or still within expiry
                        if entry.valid &amp;&amp; (time.Since(entry.validated) &lt; 24*time.Hour || time.Now().Before(entry.expiresAt)) </span><span class="cov0" title="0">{
                                v.cacheMutex.RUnlock()
                                return true, nil
                        }</span>
                }
                <span class="cov0" title="0">v.cacheMutex.RUnlock()
                return false, err</span>
        }

        <span class="cov0" title="0">return response.Valid, nil</span>
}

// GetStatus returns detailed license status
func (v *Validator) GetStatus(ctx context.Context) (*ValidationResponse, error) <span class="cov0" title="0">{
        return v.ValidateLicense(ctx)
}</span>

// ClearCache clears the validation cache
func (v *Validator) ClearCache() <span class="cov0" title="0">{
        v.cacheMutex.Lock()
        defer v.cacheMutex.Unlock()
        v.cache = make(map[string]*cacheEntry)
}</span>

// GetLicenseInfo returns formatted license information
func (v *Validator) GetLicenseInfo(ctx context.Context) (string, error) <span class="cov0" title="0">{
        status, err := v.GetStatus(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov0" title="0">info := fmt.Sprintf("License Status: %s\n", func() string </span><span class="cov0" title="0">{
                if status.Valid </span><span class="cov0" title="0">{
                        return "âœ“ Valid"
                }</span>
                <span class="cov0" title="0">return "âœ— Invalid"</span>
        }())

        <span class="cov0" title="0">if status.Message != "" </span><span class="cov0" title="0">{
                info += fmt.Sprintf("Message: %s\n", status.Message)
        }</span>

        <span class="cov0" title="0">if status.ExpiresAt != nil </span><span class="cov0" title="0">{
                info += fmt.Sprintf("License Expires: %s\n", *status.ExpiresAt)
        }</span>

        <span class="cov0" title="0">if status.UserEmail != nil </span><span class="cov0" title="0">{
                info += fmt.Sprintf("User: %s\n", *status.UserEmail)
        }</span>

        <span class="cov0" title="0">if status.TokensUsed != nil &amp;&amp; status.MaxTokens != nil </span><span class="cov0" title="0">{
                info += fmt.Sprintf("Tokens: %d/%d used\n", *status.TokensUsed, *status.MaxTokens)
        }</span>

        <span class="cov0" title="0">return info, nil</span>
}</pre>
		
		<pre class="file" id="file5" style="display: none">package logger

import (
        "fmt"
        "log"
        "os"
)

// Logger interface for performance monitoring
type Logger interface {
        Info(format string, args ...interface{})
        Debug(format string, args ...interface{})
        Error(format string, args ...interface{})
        Printf(format string, args ...interface{})
}

// SimpleLogger implements basic logging functionality
type SimpleLogger struct {
        verbose bool
        logger  *log.Logger
}

// NewSimpleLogger creates a new simple logger
func NewSimpleLogger(verbose bool) Logger <span class="cov0" title="0">{
        return &amp;SimpleLogger{
                verbose: verbose,
                logger:  log.New(os.Stdout, "[Squawk] ", log.LstdFlags),
        }
}</span>

// Info logs an info message
func (l *SimpleLogger) Info(format string, args ...interface{}) <span class="cov0" title="0">{
        l.logger.Printf("INFO: "+format, args...)
}</span>

// Debug logs a debug message (only if verbose is enabled)
func (l *SimpleLogger) Debug(format string, args ...interface{}) <span class="cov0" title="0">{
        if l.verbose </span><span class="cov0" title="0">{
                l.logger.Printf("DEBUG: "+format, args...)
        }</span>
}

// Error logs an error message
func (l *SimpleLogger) Error(format string, args ...interface{}) <span class="cov0" title="0">{
        l.logger.Printf("ERROR: "+format, args...)
}</span>

// Printf logs a formatted message
func (l *SimpleLogger) Printf(format string, args ...interface{}) <span class="cov0" title="0">{
        fmt.Printf(format, args...)
}</pre>
		
		<pre class="file" id="file6" style="display: none">package performance

import (
        "context"
        "crypto/sha256"
        "crypto/tls"
        "crypto/x509"
        "encoding/json"
        "fmt"
        "io"
        "math/rand"
        "net/http"
        "net/http/httptrace"
        "net/url"
        "os"
        "strings"
        "sync"
        "time"

        "github.com/penguincloud/squawk/dns-client-go/pkg/client"
        "github.com/penguincloud/squawk/dns-client-go/pkg/logger"
)

// DNSPerformanceStats represents comprehensive DNS over HTTP performance metrics
type DNSPerformanceStats struct {
        // Request Information
        Timestamp         time.Time `json:"timestamp"`
        ClientID          string    `json:"client_id"`
        ServerURL         string    `json:"server_url"`
        TestDomain        string    `json:"test_domain"`
        QueryType         string    `json:"query_type"`
        
        // Network Timing (similar to http-traceroute)
        DNSLookup         Duration  `json:"dns_lookup"`          // DNS resolution time
        TCPConnection     Duration  `json:"tcp_connection"`      // TCP connect time  
        TLSHandshake      Duration  `json:"tls_handshake"`       // TLS handshake time
        ServerProcessing  Duration  `json:"server_processing"`   // Time to first byte
        ContentTransfer   Duration  `json:"content_transfer"`    // Content download time
        
        // Total Times
        TotalTime         Duration  `json:"total_time"`          // End-to-end total time
        NameLookup        Duration  `json:"name_lookup"`         // DNS + TCP + TLS
        Connect           Duration  `json:"connect"`             // TCP + TLS
        
        // HTTP Details
        HTTPStatus        int       `json:"http_status"`
        HTTPHeaders       int       `json:"http_headers_size"`
        ResponseSize      int64     `json:"response_size"`
        
        // DNS Response Details
        DNSStatus         string    `json:"dns_status"`          // NOERROR, NXDOMAIN, etc.
        DNSAnswerCount    int       `json:"dns_answer_count"`
        DNSResponseCode   int       `json:"dns_response_code"`
        CacheHit          bool      `json:"cache_hit"`
        
        // Network Information
        LocalAddr         string    `json:"local_addr"`
        RemoteAddr        string    `json:"remote_addr"`
        Protocol          string    `json:"protocol"`            // HTTP/1.1, HTTP/2, etc.
        TLSVersion        string    `json:"tls_version"`
        TLSCipherSuite    string    `json:"tls_cipher_suite"`
        
        // Error Information
        ErrorType         string    `json:"error_type,omitempty"`
        ErrorMessage      string    `json:"error_message,omitempty"`
        Successful        bool      `json:"successful"`
        
        // Performance Metrics
        Jitter            Duration  `json:"jitter,omitempty"`           // Compared to baseline
        PacketLoss        float64   `json:"packet_loss,omitempty"`     // If detectable
        Retries           int       `json:"retries"`
}

// Duration wraps time.Duration for better JSON marshaling
type Duration struct {
        time.Duration
}

func (d Duration) MarshalJSON() ([]byte, error) <span class="cov0" title="0">{
        return json.Marshal(map[string]interface{}{
                "nanoseconds":  d.Duration.Nanoseconds(),
                "milliseconds": float64(d.Duration.Nanoseconds()) / 1e6,
                "human":        d.Duration.String(),
        })
}</span>

func (d *Duration) UnmarshalJSON(data []byte) error <span class="cov0" title="0">{
        var temp map[string]interface{}
        if err := json.Unmarshal(data, &amp;temp); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        
        <span class="cov0" title="0">if ns, ok := temp["nanoseconds"].(float64); ok </span><span class="cov0" title="0">{
                d.Duration = time.Duration(int64(ns))
        }</span>
        
        <span class="cov0" title="0">return nil</span>
}

// DNSPerformanceMonitor handles DNS over HTTP performance monitoring
type DNSPerformanceMonitor struct {
        config           *client.Config
        client           *http.Client
        logger           logger.Logger
        stopChan         chan struct{}
        wg               sync.WaitGroup
        
        // Performance tracking
        baseline         map[string]Duration  // Baseline response times per domain
        recentStats      []DNSPerformanceStats
        statsMutex       sync.RWMutex
        
        // Test domains for performance monitoring
        testDomains      []string
        
        // Upload configuration
        uploadURL        string
        uploadInterval   time.Duration
        uploadBatchSize  int
}

// NewDNSPerformanceMonitor creates a new performance monitor
func NewDNSPerformanceMonitor(cfg *client.Config, log logger.Logger) *DNSPerformanceMonitor <span class="cov0" title="0">{
        // Create HTTP client with tracing capabilities
        transport := &amp;http.Transport{
                TLSClientConfig: &amp;tls.Config{
                        InsecureSkipVerify: !cfg.VerifySSL,
                },
                DisableKeepAlives: false, // Keep connections alive for better performance
                MaxIdleConns:      10,
                IdleConnTimeout:   30 * time.Second,
        }
        
        // Load client certificates if provided
        if cfg.ClientCert != "" &amp;&amp; cfg.ClientKey != "" </span><span class="cov0" title="0">{
                cert, err := tls.LoadX509KeyPair(cfg.ClientCert, cfg.ClientKey)
                if err == nil </span><span class="cov0" title="0">{
                        transport.TLSClientConfig.Certificates = []tls.Certificate{cert}
                }</span>
        }
        
        // Load CA certificate if provided
        <span class="cov0" title="0">if cfg.CaCert != "" </span><span class="cov0" title="0">{
                caCert, err := os.ReadFile(cfg.CaCert)
                if err == nil </span><span class="cov0" title="0">{
                        caCertPool := x509.NewCertPool()
                        caCertPool.AppendCertsFromPEM(caCert)
                        transport.TLSClientConfig.RootCAs = caCertPool
                }</span>
        }
        
        <span class="cov0" title="0">client := &amp;http.Client{
                Transport: transport,
                Timeout:   30 * time.Second, // Default timeout
        }
        
        // Default test domains for performance monitoring
        testDomains := []string{
                "google.com",
                "cloudflare.com", 
                "example.com",
                "github.com",
                cfg.ServerURL, // Include the DNS server itself
        }
        
        uploadURL := cfg.ServerURL
        if !strings.HasSuffix(uploadURL, "/") </span><span class="cov0" title="0">{
                uploadURL += "/"
        }</span>
        <span class="cov0" title="0">uploadURL += "api/performance/upload"
        
        return &amp;DNSPerformanceMonitor{
                config:          cfg,
                client:          client,
                logger:          log,
                stopChan:        make(chan struct{}),
                baseline:        make(map[string]Duration),
                recentStats:     make([]DNSPerformanceStats, 0, 100),
                testDomains:     testDomains,
                uploadURL:       uploadURL,
                uploadInterval:  5 * time.Minute,  // Upload every 5 minutes
                uploadBatchSize: 50,               // Upload up to 50 stats at once
        }</span>
}

// Start begins performance monitoring
func (pm *DNSPerformanceMonitor) Start() error <span class="cov0" title="0">{
        pm.logger.Info("Starting DNS performance monitoring")
        
        pm.wg.Add(2)
        
        // Start performance testing goroutine
        go pm.performanceTestLoop()
        
        // Start upload goroutine  
        go pm.uploadLoop()
        
        return nil
}</span>

// Stop stops performance monitoring
func (pm *DNSPerformanceMonitor) Stop() error <span class="cov0" title="0">{
        pm.logger.Info("Stopping DNS performance monitoring")
        
        close(pm.stopChan)
        pm.wg.Wait()
        
        // Upload any remaining stats
        pm.uploadStats()
        
        return nil
}</span>

// performanceTestLoop runs performance tests at random intervals
func (pm *DNSPerformanceMonitor) performanceTestLoop() <span class="cov0" title="0">{
        defer pm.wg.Done()
        
        ticker := time.NewTicker(time.Minute) // Check every minute if we should test
        defer ticker.Stop()
        
        for </span><span class="cov0" title="0">{
                select </span>{
                case &lt;-pm.stopChan:<span class="cov0" title="0">
                        return</span>
                        
                case &lt;-ticker.C:<span class="cov0" title="0">
                        // Random interval between 5 and 10 minutes
                        nextTest := rand.Intn(5*60) + 5*60 // 5-10 minutes in seconds
                        
                        timer := time.NewTimer(time.Duration(nextTest) * time.Second)
                        
                        select </span>{
                        case &lt;-pm.stopChan:<span class="cov0" title="0">
                                timer.Stop()
                                return</span>
                                
                        case &lt;-timer.C:<span class="cov0" title="0">
                                pm.runPerformanceTest()</span>
                        }
                }
        }
}

// runPerformanceTest performs a comprehensive DNS over HTTP performance test
func (pm *DNSPerformanceMonitor) runPerformanceTest() <span class="cov0" title="0">{
        // Select random test domain
        domain := pm.testDomains[rand.Intn(len(pm.testDomains))]
        
        pm.logger.Debug("Running performance test for domain: %s", domain)
        
        stats := pm.performDNSOverHTTPTest(domain, "A")
        
        pm.statsMutex.Lock()
        pm.recentStats = append(pm.recentStats, stats)
        
        // Keep only recent stats (last 100)
        if len(pm.recentStats) &gt; 100 </span><span class="cov0" title="0">{
                pm.recentStats = pm.recentStats[len(pm.recentStats)-100:]
        }</span>
        <span class="cov0" title="0">pm.statsMutex.Unlock()
        
        // Update baseline if successful
        if stats.Successful </span><span class="cov0" title="0">{
                pm.updateBaseline(domain, stats.TotalTime)
        }</span>
        
        <span class="cov0" title="0">pm.logger.Debug("Performance test completed: %s in %v", domain, stats.TotalTime.Duration)</span>
}

// performDNSOverHTTPTest performs detailed DNS over HTTP test with timing breakdown
func (pm *DNSPerformanceMonitor) performDNSOverHTTPTest(domain, queryType string) DNSPerformanceStats <span class="cov0" title="0">{
        stats := DNSPerformanceStats{
                Timestamp:    time.Now(),
                ClientID:     pm.generateClientID(),
                ServerURL:    pm.config.ServerURL,
                TestDomain:   domain,
                QueryType:    queryType,
                Protocol:     "HTTP/1.1", // Will be updated based on actual connection
                Successful:   false,
        }
        
        // Create DNS over HTTP request URL
        dnsURL, err := url.Parse(pm.config.ServerURL)
        if err != nil </span><span class="cov0" title="0">{
                stats.ErrorType = "url_parse_error"
                stats.ErrorMessage = err.Error()
                return stats
        }</span>
        
        // Add DNS query parameters
        <span class="cov0" title="0">params := url.Values{}
        params.Set("name", domain)
        params.Set("type", queryType)
        dnsURL.RawQuery = params.Encode()
        
        // Create request with tracing
        req, err := http.NewRequest("GET", dnsURL.String(), nil)
        if err != nil </span><span class="cov0" title="0">{
                stats.ErrorType = "request_creation_error"
                stats.ErrorMessage = err.Error()
                return stats
        }</span>
        
        // Set headers
        <span class="cov0" title="0">req.Header.Set("Accept", "application/dns-json")
        req.Header.Set("User-Agent", "Squawk-DNS-Client/2.0 Performance-Monitor")
        
        if pm.config.AuthToken != "" </span><span class="cov0" title="0">{
                req.Header.Set("Authorization", "Bearer "+pm.config.AuthToken)
        }</span>
        
        // Setup request tracing
        <span class="cov0" title="0">var (
                dnsStart, dnsEnd         time.Time
                connectStart, connectEnd time.Time
                tlsStart, tlsEnd         time.Time
                reqStart, reqEnd         time.Time
                firstByteTime            time.Time
                localAddr, remoteAddr    string
        )
        
        trace := &amp;httptrace.ClientTrace{
                DNSStart: func(info httptrace.DNSStartInfo) </span><span class="cov0" title="0">{
                        dnsStart = time.Now()
                }</span>,
                DNSDone: func(info httptrace.DNSDoneInfo) <span class="cov0" title="0">{
                        dnsEnd = time.Now()
                        stats.DNSLookup = Duration{dnsEnd.Sub(dnsStart)}
                }</span>,
                ConnectStart: func(network, addr string) <span class="cov0" title="0">{
                        connectStart = time.Now()
                }</span>,
                ConnectDone: func(network, addr string, err error) <span class="cov0" title="0">{
                        connectEnd = time.Now()
                        stats.TCPConnection = Duration{connectEnd.Sub(connectStart)}
                        remoteAddr = addr
                }</span>,
                TLSHandshakeStart: func() <span class="cov0" title="0">{
                        tlsStart = time.Now()
                }</span>,
                TLSHandshakeDone: func(state tls.ConnectionState, err error) <span class="cov0" title="0">{
                        tlsEnd = time.Now()
                        stats.TLSHandshake = Duration{tlsEnd.Sub(tlsStart)}
                        
                        if err == nil </span><span class="cov0" title="0">{
                                stats.TLSVersion = pm.tlsVersionString(state.Version)
                                stats.TLSCipherSuite = tls.CipherSuiteName(state.CipherSuite)
                                stats.Protocol = state.NegotiatedProtocol
                                if stats.Protocol == "" </span><span class="cov0" title="0">{
                                        stats.Protocol = "HTTP/1.1"
                                }</span>
                        }
                },
                GotFirstResponseByte: func() <span class="cov0" title="0">{
                        firstByteTime = time.Now()
                }</span>,
                GotConn: func(info httptrace.GotConnInfo) <span class="cov0" title="0">{
                        if info.Conn != nil </span><span class="cov0" title="0">{
                                localAddr = info.Conn.LocalAddr().String()
                                if remoteAddr == "" </span><span class="cov0" title="0">{
                                        remoteAddr = info.Conn.RemoteAddr().String()
                                }</span>
                        }
                },
        }
        
        <span class="cov0" title="0">req = req.WithContext(httptrace.WithClientTrace(req.Context(), trace))
        
        // Perform the request
        reqStart = time.Now()
        resp, err := pm.client.Do(req)
        reqEnd = time.Now()
        
        stats.LocalAddr = localAddr
        stats.RemoteAddr = remoteAddr
        
        if err != nil </span><span class="cov0" title="0">{
                stats.ErrorType = "http_request_error"
                stats.ErrorMessage = err.Error()
                stats.TotalTime = Duration{reqEnd.Sub(reqStart)}
                return stats
        }</span>
        <span class="cov0" title="0">defer resp.Body.Close()
        
        // Read response
        body, err := io.ReadAll(resp.Body)
        contentEnd := time.Now()
        
        stats.HTTPStatus = resp.StatusCode
        stats.ResponseSize = int64(len(body))
        stats.HTTPHeaders = pm.calculateHeadersSize(resp.Header)
        
        // Calculate timing metrics
        stats.TotalTime = Duration{contentEnd.Sub(reqStart)}
        
        if !firstByteTime.IsZero() </span><span class="cov0" title="0">{
                stats.ServerProcessing = Duration{firstByteTime.Sub(reqStart)}
                stats.ContentTransfer = Duration{contentEnd.Sub(firstByteTime)}
        }</span>
        
        <span class="cov0" title="0">stats.NameLookup = Duration{stats.DNSLookup.Duration + stats.TCPConnection.Duration + stats.TLSHandshake.Duration}
        stats.Connect = Duration{stats.TCPConnection.Duration + stats.TLSHandshake.Duration}
        
        if err != nil </span><span class="cov0" title="0">{
                stats.ErrorType = "response_read_error"
                stats.ErrorMessage = err.Error()
                return stats
        }</span>
        
        // Parse DNS response if successful
        <span class="cov0" title="0">if resp.StatusCode == 200 </span><span class="cov0" title="0">{
                pm.parseDNSResponse(body, &amp;stats)
                stats.Successful = true
        }</span> else<span class="cov0" title="0"> {
                stats.ErrorType = "http_error"
                stats.ErrorMessage = fmt.Sprintf("HTTP %d", resp.StatusCode)
        }</span>
        
        // Calculate jitter if we have baseline
        <span class="cov0" title="0">if baseline, exists := pm.baseline[domain]; exists </span><span class="cov0" title="0">{
                jitter := stats.TotalTime.Duration - baseline.Duration
                if jitter &lt; 0 </span><span class="cov0" title="0">{
                        jitter = -jitter
                }</span>
                <span class="cov0" title="0">stats.Jitter = Duration{jitter}</span>
        }
        
        <span class="cov0" title="0">return stats</span>
}

// parseDNSResponse parses the DNS over HTTP JSON response
func (pm *DNSPerformanceMonitor) parseDNSResponse(body []byte, stats *DNSPerformanceStats) <span class="cov0" title="0">{
        var response map[string]interface{}
        if err := json.Unmarshal(body, &amp;response); err != nil </span><span class="cov0" title="0">{
                stats.DNSStatus = "PARSE_ERROR"
                return
        }</span>
        
        // Extract DNS response code
        <span class="cov0" title="0">if status, ok := response["Status"].(float64); ok </span><span class="cov0" title="0">{
                stats.DNSResponseCode = int(status)
                switch int(status) </span>{
                case 0:<span class="cov0" title="0">
                        stats.DNSStatus = "NOERROR"</span>
                case 3:<span class="cov0" title="0">
                        stats.DNSStatus = "NXDOMAIN"</span>
                default:<span class="cov0" title="0">
                        stats.DNSStatus = fmt.Sprintf("RCODE_%d", int(status))</span>
                }
        }
        
        // Extract answer count
        <span class="cov0" title="0">if answers, ok := response["Answer"].([]interface{}); ok </span><span class="cov0" title="0">{
                stats.DNSAnswerCount = len(answers)
        }</span>
        
        // Check for cache hit indicator
        <span class="cov0" title="0">if comment, ok := response["Comment"].(string); ok </span><span class="cov0" title="0">{
                stats.CacheHit = strings.Contains(strings.ToLower(comment), "cache")
        }</span>
}

// updateBaseline updates the baseline response time for a domain
func (pm *DNSPerformanceMonitor) updateBaseline(domain string, responseTime Duration) <span class="cov0" title="0">{
        pm.statsMutex.Lock()
        defer pm.statsMutex.Unlock()
        
        if existing, exists := pm.baseline[domain]; exists </span><span class="cov0" title="0">{
                // Use exponential moving average: new_baseline = 0.8 * old + 0.2 * new
                newTime := time.Duration(float64(existing.Duration)*0.8 + float64(responseTime.Duration)*0.2)
                pm.baseline[domain] = Duration{newTime}
        }</span> else<span class="cov0" title="0"> {
                pm.baseline[domain] = responseTime
        }</span>
}

// uploadLoop handles periodic upload of performance stats
func (pm *DNSPerformanceMonitor) uploadLoop() <span class="cov0" title="0">{
        defer pm.wg.Done()
        
        ticker := time.NewTicker(pm.uploadInterval)
        defer ticker.Stop()
        
        for </span><span class="cov0" title="0">{
                select </span>{
                case &lt;-pm.stopChan:<span class="cov0" title="0">
                        return</span>
                        
                case &lt;-ticker.C:<span class="cov0" title="0">
                        pm.uploadStats()</span>
                }
        }
}

// uploadStats uploads collected performance statistics to the server
func (pm *DNSPerformanceMonitor) uploadStats() <span class="cov0" title="0">{
        pm.statsMutex.Lock()
        if len(pm.recentStats) == 0 </span><span class="cov0" title="0">{
                pm.statsMutex.Unlock()
                return
        }</span>
        
        // Take up to uploadBatchSize stats
        <span class="cov0" title="0">batchSize := len(pm.recentStats)
        if batchSize &gt; pm.uploadBatchSize </span><span class="cov0" title="0">{
                batchSize = pm.uploadBatchSize
        }</span>
        
        <span class="cov0" title="0">statsToUpload := make([]DNSPerformanceStats, batchSize)
        copy(statsToUpload, pm.recentStats[:batchSize])
        
        // Remove uploaded stats
        pm.recentStats = pm.recentStats[batchSize:]
        pm.statsMutex.Unlock()
        
        pm.logger.Debug("Uploading %d performance statistics", len(statsToUpload))
        
        // Create upload payload
        payload := map[string]interface{}{
                "client_id":    pm.generateClientID(),
                "timestamp":    time.Now(),
                "stats_count":  len(statsToUpload),
                "statistics":   statsToUpload,
        }
        
        jsonData, err := json.Marshal(payload)
        if err != nil </span><span class="cov0" title="0">{
                pm.logger.Error("Failed to marshal performance stats: %v", err)
                return
        }</span>
        
        // Create upload request
        <span class="cov0" title="0">req, err := http.NewRequest("POST", pm.uploadURL, strings.NewReader(string(jsonData)))
        if err != nil </span><span class="cov0" title="0">{
                pm.logger.Error("Failed to create upload request: %v", err)
                return
        }</span>
        
        <span class="cov0" title="0">req.Header.Set("Content-Type", "application/json")
        req.Header.Set("User-Agent", "Squawk-DNS-Client/2.0 Performance-Monitor")
        
        if pm.config.AuthToken != "" </span><span class="cov0" title="0">{
                req.Header.Set("Authorization", "Bearer "+pm.config.AuthToken)
        }</span>
        
        // Perform upload
        <span class="cov0" title="0">ctx, cancel := context.WithTimeout(context.Background(), 30*time.Second)
        defer cancel()
        
        req = req.WithContext(ctx)
        
        resp, err := pm.client.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                pm.logger.Error("Failed to upload performance stats: %v", err)
                return
        }</span>
        <span class="cov0" title="0">defer resp.Body.Close()
        
        if resp.StatusCode != 200 </span><span class="cov0" title="0">{
                pm.logger.Error("Performance stats upload failed with status: %d", resp.StatusCode)
                return
        }</span>
        
        <span class="cov0" title="0">pm.logger.Debug("Successfully uploaded %d performance statistics", len(statsToUpload))</span>
}

// generateClientID generates a unique client identifier
func (pm *DNSPerformanceMonitor) generateClientID() string <span class="cov0" title="0">{
        hostname, _ := os.Hostname()
        if hostname == "" </span><span class="cov0" title="0">{
                hostname = "unknown"
        }</span>
        
        // Include hostname and a hash of server URL for uniqueness
        <span class="cov0" title="0">h := sha256.Sum256([]byte(pm.config.ServerURL + hostname))
        return fmt.Sprintf("%s-%x", hostname, h[:8])</span>
}

// tlsVersionString converts TLS version number to string
func (pm *DNSPerformanceMonitor) tlsVersionString(version uint16) string <span class="cov0" title="0">{
        switch version </span>{
        case tls.VersionTLS10:<span class="cov0" title="0">
                return "TLS 1.0"</span>
        case tls.VersionTLS11:<span class="cov0" title="0">
                return "TLS 1.1"</span>
        case tls.VersionTLS12:<span class="cov0" title="0">
                return "TLS 1.2"</span>
        case tls.VersionTLS13:<span class="cov0" title="0">
                return "TLS 1.3"</span>
        default:<span class="cov0" title="0">
                return fmt.Sprintf("TLS 0x%04x", version)</span>
        }
}

// calculateHeadersSize calculates the size of HTTP headers
func (pm *DNSPerformanceMonitor) calculateHeadersSize(headers http.Header) int <span class="cov0" title="0">{
        size := 0
        for key, values := range headers </span><span class="cov0" title="0">{
                for _, value := range values </span><span class="cov0" title="0">{
                        size += len(key) + len(value) + 4 // +4 for ": " and "\r\n"
                }</span>
        }
        <span class="cov0" title="0">return size</span>
}

// GetRecentStats returns recent performance statistics
func (pm *DNSPerformanceMonitor) GetRecentStats() []DNSPerformanceStats <span class="cov0" title="0">{
        pm.statsMutex.RLock()
        defer pm.statsMutex.RUnlock()
        
        // Return a copy to avoid race conditions
        stats := make([]DNSPerformanceStats, len(pm.recentStats))
        copy(stats, pm.recentStats)
        
        return stats
}</span>

// GetBaselines returns current performance baselines
func (pm *DNSPerformanceMonitor) GetBaselines() map[string]Duration <span class="cov0" title="0">{
        pm.statsMutex.RLock()
        defer pm.statsMutex.RUnlock()
        
        // Return a copy
        baselines := make(map[string]Duration)
        for k, v := range pm.baseline </span><span class="cov0" title="0">{
                baselines[k] = v
        }</span>
        
        <span class="cov0" title="0">return baselines</span>
}</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
